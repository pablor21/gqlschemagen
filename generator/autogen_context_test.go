package generator

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// TestAutoGenContextAwareTypeInput tests that auto-generation is context-aware:
// - Types referenced by @gqlType should be auto-generated as types
// - Types referenced by @gqlInput should be auto-generated as inputs
func TestAutoGenContextAwareTypeInput(t *testing.T) {
	// Create temporary directory
	tmpDir, err := os.MkdirTemp("", "gqlschemagen-context-test-*")
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Logf("Failed to remove temp dir: %v", err)
		}
	}()

	// Create test files
	modelsDir := filepath.Join(tmpDir, "models")
	if err := os.MkdirAll(modelsDir, 0755); err != nil {
		t.Fatal(err)
	}

	// Create a referenced type (Address) that will be auto-generated
	addressFile := `package models

type Address struct {
	Street  string
	City    string
	ZipCode string
}
`
	if err := os.WriteFile(filepath.Join(modelsDir, "address.go"), []byte(addressFile), 0644); err != nil {
		t.Fatal(err)
	}

	// Create a type that references Address (should auto-gen Address as type)
	userFile := `package models

/**
 * @gqlType
 */
type User struct {
	ID      string
	Name    string
	Address Address
}
`
	if err := os.WriteFile(filepath.Join(modelsDir, "user.go"), []byte(userFile), 0644); err != nil {
		t.Fatal(err)
	}

	// Create an input that references Address (should auto-gen Address as input)
	createUserFile := `package models

/**
 * @gqlInput
 */
type CreateUserInput struct {
	Name    string
	Address Address
}
`
	if err := os.WriteFile(filepath.Join(modelsDir, "create_user.go"), []byte(createUserFile), 0644); err != nil {
		t.Fatal(err)
	}

	// Parse packages
	parser := NewParser()
	if err := parser.Walk(modelsDir); err != nil {
		t.Fatal(err)
	}

	// Configure generator with auto-generation enabled
	config := NewConfig()
	config.Output = filepath.Join(tmpDir, "schema")
	config.OutputFileName = "schema.graphqls"
	config.GenStrategy = GenStrategySingle
	config.AutoGenerate.Enabled = true
	config.AutoGenerate.Strategy = AutoGenReferenced
	config.AutoGenerate.MaxDepth = 2
	config.AutoGenerate.OutOfScopeTypes = OutOfScopeIgnore

	// Generate schema
	gen := NewGenerator(parser, config)
	if err := gen.Run(); err != nil {
		t.Fatal(err)
	}

	// Read generated schema
	schemaPath := filepath.Join(tmpDir, "schema", "schema.graphqls")
	content, err := os.ReadFile(schemaPath)
	if err != nil {
		t.Fatal(err)
	}
	schema := string(content)

	t.Logf("Generated schema:\n%s", schema)

	// Verify User type exists
	if !strings.Contains(schema, "type User") {
		t.Error("Expected User type to be generated")
	}

	// Verify CreateUserInput exists
	if !strings.Contains(schema, "input CreateUserInput") {
		t.Error("Expected CreateUserInput to be generated")
	}

	// Verify Address was auto-generated as a type (referenced by User type)
	if !strings.Contains(schema, "type Address") {
		t.Error("Expected Address type to be auto-generated (referenced by User type)")
	}

	// Verify Address was auto-generated as an input (referenced by CreateUserInput)
	if !strings.Contains(schema, "input AddressInput") {
		t.Error("Expected AddressInput to be auto-generated (referenced by CreateUserInput)")
	}

	// Verify auto-generated flags
	t.Logf("AutoGeneratedTypes: %v", gen.AutoGeneratedTypes)
	t.Logf("AutoGeneratedInputs: %v", gen.AutoGeneratedInputs)

	if !gen.AutoGeneratedTypes["Address"] {
		t.Error("Expected Address to be marked as auto-generated type")
	}

	if !gen.AutoGeneratedInputs["Address"] {
		t.Error("Expected Address to be marked as auto-generated input")
	}
}

// TestAutoGenOnlyTypeContext tests that when only types reference a struct, only type is generated
func TestAutoGenOnlyTypeContext(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "gqlschemagen-typeonly-test-*")
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Logf("Failed to remove temp dir: %v", err)
		}
	}()

	modelsDir := filepath.Join(tmpDir, "models")
	if err := os.MkdirAll(modelsDir, 0755); err != nil {
		t.Fatal(err)
	}

	// Referenced type
	profileFile := `package models

type Profile struct {
	Bio       string
	AvatarURL string
}
`
	if err := os.WriteFile(filepath.Join(modelsDir, "profile.go"), []byte(profileFile), 0644); err != nil {
		t.Fatal(err)
	}

	// Type that references Profile
	userFile := `package models

/**
 * @gqlType
 */
type User struct {
	ID      string
	Name    string
	Profile Profile
}
`
	if err := os.WriteFile(filepath.Join(modelsDir, "user.go"), []byte(userFile), 0644); err != nil {
		t.Fatal(err)
	}

	parser := NewParser()
	if err := parser.Walk(modelsDir); err != nil {
		t.Fatal(err)
	}

	config := NewConfig()
	config.Output = filepath.Join(tmpDir, "schema")
	config.OutputFileName = "schema.graphqls"
	config.GenStrategy = GenStrategySingle
	config.AutoGenerate.Enabled = true
	config.AutoGenerate.Strategy = AutoGenReferenced
	config.AutoGenerate.OutOfScopeTypes = OutOfScopeIgnore

	gen := NewGenerator(parser, config)
	if err := gen.Run(); err != nil {
		t.Fatal(err)
	}

	schemaPath := filepath.Join(tmpDir, "schema", "schema.graphqls")
	content, err := os.ReadFile(schemaPath)
	if err != nil {
		t.Fatal(err)
	}
	schema := string(content)

	t.Logf("Generated schema:\n%s", schema)

	// Should generate Profile as type
	if !strings.Contains(schema, "type Profile") {
		t.Error("Expected Profile type to be auto-generated")
	}

	// Should NOT generate Profile as input (no input references it)
	if strings.Contains(schema, "input ProfileInput") {
		t.Error("Did not expect ProfileInput to be generated (not referenced by any input)")
	}

	// Verify flags
	if !gen.AutoGeneratedTypes["Profile"] {
		t.Error("Expected Profile to be marked as auto-generated type")
	}

	if gen.AutoGeneratedInputs["Profile"] {
		t.Error("Did not expect Profile to be marked as auto-generated input")
	}
}

// TestAutoGenOnlyInputContext tests that when only inputs reference a struct, only input is generated
func TestAutoGenOnlyInputContext(t *testing.T) {
	tmpDir, err := os.MkdirTemp("", "gqlschemagen-inputonly-test-*")
	if err != nil {
		t.Fatal(err)
	}
	defer func() {
		if err := os.RemoveAll(tmpDir); err != nil {
			t.Logf("Failed to remove temp dir: %v", err)
		}
	}()

	modelsDir := filepath.Join(tmpDir, "models")
	if err := os.MkdirAll(modelsDir, 0755); err != nil {
		t.Fatal(err)
	}

	// Referenced type
	settingsFile := `package models

type Settings struct {
	Theme    string
	Language string
}
`
	if err := os.WriteFile(filepath.Join(modelsDir, "settings.go"), []byte(settingsFile), 0644); err != nil {
		t.Fatal(err)
	}

	// Input that references Settings
	updateUserFile := `package models

/**
 * @gqlInput
 */
type UpdateUserInput struct {
	Name     string
	Settings Settings
}
`
	if err := os.WriteFile(filepath.Join(modelsDir, "update_user.go"), []byte(updateUserFile), 0644); err != nil {
		t.Fatal(err)
	}

	parser := NewParser()
	if err := parser.Walk(modelsDir); err != nil {
		t.Fatal(err)
	}

	config := NewConfig()
	config.Output = filepath.Join(tmpDir, "schema")
	config.OutputFileName = "schema.graphqls"
	config.GenStrategy = GenStrategySingle
	config.AutoGenerate.Enabled = true
	config.AutoGenerate.Strategy = AutoGenReferenced
	config.AutoGenerate.OutOfScopeTypes = OutOfScopeIgnore

	gen := NewGenerator(parser, config)
	if err := gen.Run(); err != nil {
		t.Fatal(err)
	}

	schemaPath := filepath.Join(tmpDir, "schema", "schema.graphqls")
	content, err := os.ReadFile(schemaPath)
	if err != nil {
		t.Fatal(err)
	}
	schema := string(content)

	t.Logf("Generated schema:\n%s", schema)

	// Should NOT generate Settings as type (no type references it)
	if strings.Contains(schema, "type Settings") {
		t.Error("Did not expect Settings type to be generated (not referenced by any type)")
	}

	// Should generate Settings as input
	if !strings.Contains(schema, "input SettingsInput") {
		t.Error("Expected SettingsInput to be auto-generated")
	}

	// Verify flags
	if gen.AutoGeneratedTypes["Settings"] {
		t.Error("Did not expect Settings to be marked as auto-generated type")
	}

	if !gen.AutoGeneratedInputs["Settings"] {
		t.Error("Expected Settings to be marked as auto-generated input")
	}
}
