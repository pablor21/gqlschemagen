// Package generator provides automatic GraphQL schema generation from Go structs.
//
// This package scans Go source code for struct definitions and generates GraphQL
// type definitions, input types, and schema files based on struct tags and special
// directives. It supports field name transformations, custom type mappings, and
// automatic input generation for mutations.
//
// # Features
//
//   - Automatic GraphQL type generation from Go structs
//   - Field name transformations (camelCase, snake_case, PascalCase)
//   - Support for gql tags and directives (@gqlgen, @gqlField, etc.)
//   - Automatic input type generation from structs
//   - Custom prefix/suffix stripping from type names
//   - Support for embedded structs and referenced types
//   - Configurable output strategies (single file or per-struct)
//
// # Basic Usage
//
//	parser := generator.NewParser()
//	err := parser.ParsePackages([]string{"./models"})
//	if err != nil {
//		panic(err)
//	}
//
//	config := generator.NewConfig()
//	config.Output = "schema.graphqls"
//
//	gen := generator.NewGenerator(parser, config)
//	err = gen.Run()
//	if err != nil {
//		panic(err)
//	}
//
// For detailed documentation and examples, see:
// https://github.com/pablor21/gqlschemagen
package generator

import (
	"fmt"
	"go/ast"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type Generator struct {
	P      *Parser
	Config *Config

	// AutoGeneratedTypes tracks types that should be auto-generated as GraphQL types
	// Key: type name, Value: true if should generate as type
	AutoGeneratedTypes map[string]bool

	// AutoGeneratedInputs tracks types that should be auto-generated as GraphQL inputs
	// Key: type name, Value: true if should generate as input
	AutoGeneratedInputs map[string]bool

	// OutOfScopeTypes tracks type references that are out of scope
	// Key: type name, Value: slice of field references with detailed info
	OutOfScopeTypes map[string][]OutOfScopeReference

	// GenericInstantiations tracks generic types that need concrete instantiations
	// Key: concrete type name (e.g., "CommentEdge"), Value: instantiation info
	GenericInstantiations map[string]*GenericInstantiation

	// ConcreteTypeContents stores the generated GraphQL content for concrete types
	// Key: concrete type name, Value: GraphQL schema content
	ConcreteTypeContents map[string]string

	// GeneratedItems tracks all generated GraphQL schema items
	GeneratedItems []GQLSchemaItem
}

// GenericInstantiation represents a concrete instantiation of a generic type
type GenericInstantiation struct {
	// GenericTypeName is the base generic type name (e.g., "Edge")
	GenericTypeName string
	// ConcreteTypeName is the generated concrete type name (e.g., "CommentEdge")
	ConcreteTypeName string
	// TypeArguments are the resolved type arguments
	TypeArguments []ast.Expr
	// Context is the generation context with type substitutions
	Context *GenerationContext
}

// OutOfScopeReference tracks a reference to an out-of-scope type
type OutOfScopeReference struct {
	ParentGoType   string // Go type of the parent struct (e.g., "Company")
	ParentGQLName  string // GraphQL name of the parent (e.g., "Company" or "CreateCompanyInput")
	GoFieldName    string // Go field name (e.g., "Test")
	FieldName      string // GraphQL field name (e.g., "test")
	GoFieldType    string // Go field type (e.g., "outofscope.AnotherOutOfScope")
	ReferencedType string // Referenced GraphQL type name (e.g., "AnotherOutOfScope")
}

// GQLSchemaItem represents a generated GraphQL schema item
type GQLSchemaItem struct {
	// OutputFile is the path to the generated schema file
	OutputFile string
	// GoSourceFile is the absolute path to the Go source file
	GoSourceFile string
	// GoType is the fully qualified Go type name (e.g., "github.com/user/pkg/models.User")
	GoType string
	// GoTypeName is the simple Go type name (e.g., "User")
	GoTypeName string
	// GQLName is the GraphQL type/input/enum name
	GQLName string
	// GQLKind is the kind of GraphQL schema item (type, input, enum)
	GQLKind string
	// Strategy is the generation strategy used (single, multiple, package, namespace)
	Strategy string
	// AutoGenerated indicates if this was auto-generated
	AutoGenerated bool
	// Namespace is the namespace if applicable
	Namespace string
}

// GenerationContext holds context for generating a specific GraphQL item
type GenerationContext struct {
	OutputFile string
	Strategy   string
	Namespace  string
	// TypeSubstitutions maps type parameter names (T, K, V) to their concrete type expressions
	// Used when expanding generic types to resolve type parameters to actual types
	// e.g., when expanding Result[*User], T maps to the *User AST expression
	TypeSubstitutions map[string]ast.Expr
}

func NewGenerator(p *Parser, config *Config) *Generator {
	if config == nil {
		config = NewConfig()
	}
	config.Normalize()
	return &Generator{
		P:                     p,
		Config:                config,
		AutoGeneratedTypes:    make(map[string]bool),
		AutoGeneratedInputs:   make(map[string]bool),
		OutOfScopeTypes:       make(map[string][]OutOfScopeReference),
		GenericInstantiations: make(map[string]*GenericInstantiation),
		ConcreteTypeContents:  make(map[string]string),
		GeneratedItems:        []GQLSchemaItem{},
	}
}

func (g *Generator) Run() error {
	// Build dependency graph and mark types for auto-generation
	if g.Config.AutoGenerate.Enabled {
		depGraph := g.BuildDependencyGraph()
		depGraph.MarkTypesForGeneration(g.Config)

		// Update parser's TypeNames to include auto-generated types
		g.applyAutoGeneration(depGraph)
	}

	// Build scanned types registry with GQL annotation metadata
	g.buildScannedTypesRegistry()

	// Check if we have any namespaces defined
	hasNamespaces := len(g.P.TypeNamespaces) > 0 || len(g.P.EnumNamespaces) > 0

	// Ensure output directory exists
	outputDir := g.Config.Output
	if g.Config.GenStrategy == GenStrategySingle && !hasNamespaces {
		// For single strategy without namespaces, check if Output is a file path or directory
		// If it ends with an extension, it's a file path - extract the directory
		if strings.HasSuffix(g.Config.Output, ".graphqls") || strings.HasSuffix(g.Config.Output, ".graphql") || strings.HasSuffix(g.Config.Output, ".gql") {
			outputDir = filepath.Dir(g.Config.Output)
		} else {
			outputDir = g.Config.Output
		}
	} else if g.Config.GenStrategy == GenStrategySingle && hasNamespaces {
		// When using namespaces with single strategy, output path should be treated as directory
		outputDir = g.Config.Output
	}
	if err := EnsureDir(outputDir); err != nil {
		return err
	}

	// Build topological order (AFTER auto-generation adds types to TypeNames)
	orders := g.buildDependencyOrder()

	// If namespaces are defined AND we're using package strategy, merge both approaches
	// If namespaces are defined with single/multiple strategy, use namespace generation
	// Otherwise, use the configured strategy
	var fileContents map[string]string
	var err error
	if hasNamespaces && g.Config.GenStrategy == GenStrategyPackage {
		fileContents, err = g.generateByNamespaceAndPackage(orders)
	} else if hasNamespaces {
		fileContents, err = g.generateByNamespace(orders)
	} else {
		// Generate based on strategy
		switch g.Config.GenStrategy {
		case GenStrategySingle:
			fileContents, err = g.generateSingleFile(orders)
		case GenStrategyPackage:
			fileContents, err = g.generatePackageFiles(orders)
		default: // GenStrategyMultiple
			fileContents, err = g.generateMultipleFiles(orders)
		}
	}

	if err != nil {
		return err
	}

	// Report out-of-scope types if any were found (BEFORE writing files)
	if len(g.OutOfScopeTypes) > 0 {
		outOfScopeErr := g.reportOutOfScopeTypes()
		if outOfScopeErr != nil {
			return outOfScopeErr
		}
	}

	// All validations passed - now write the files
	for outFile, content := range fileContents {
		if len(content) > 0 {
			// Ensure directory exists
			if err := EnsureDir(filepath.Dir(outFile)); err != nil {
				return err
			}
			if err := WriteFile(outFile, content, g.Config); err != nil {
				return err
			}
		}
	}

	// Log generation summary
	g.logGenerationSummary()

	return nil
}

// registerGeneratedItem records a generated GraphQL schema item
func (g *Generator) registerGeneratedItem(item GQLSchemaItem) {
	g.GeneratedItems = append(g.GeneratedItems, item)
}

// logGenerationSummary logs a summary of all generated items
func (g *Generator) logGenerationSummary() {
	if len(g.GeneratedItems) == 0 {
		return
	}

	slog.Info("Generation summary", "total_items", len(g.GeneratedItems))

	// Group by kind
	byKind := make(map[string]int)
	byStrategy := make(map[string]int)
	autoGenCount := 0

	for _, item := range g.GeneratedItems {
		byKind[item.GQLKind]++
		byStrategy[item.Strategy]++
		if item.AutoGenerated {
			autoGenCount++
		}
	}

	slog.Debug("Generation details",
		"types", byKind["type"],
		"inputs", byKind["input"],
		"enums", byKind["enum"],
		"auto_generated", autoGenCount,
	)

	// Log detailed items in debug mode
	for _, item := range g.GeneratedItems {
		slog.Debug("Generated item",
			"kind", item.GQLKind,
			"gql_name", item.GQLName,
			"go_type", item.GoTypeName,
			"file", item.OutputFile,
			"auto_gen", item.AutoGenerated,
			"namespace", item.Namespace,
		)
	}
}

func (g *Generator) buildDependencyOrder() []string {
	names := make([]string, 0, len(g.P.TypeNames))
	// for _, n := range g.P.TypeNames {
	// 	names = append(names, n)
	// }
	names = append(names, g.P.TypeNames...)
	sort.Strings(names)

	// Topological sort
	orders := []string{}
	visited := map[string]bool{}
	var dfs func(string)
	dfs = func(n string) {
		if visited[n] {
			return
		}
		visited[n] = true
		typeSpec := g.P.StructTypes[n]
		st, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			return
		}
		for _, f := range st.Fields.List {
			ft := FieldTypeName(f.Type)
			if ts, ok := g.P.StructTypes[ft]; ok {
				if _, ok := ts.Type.(*ast.StructType); !ok {
					continue
				}
				dfs(ft)
			}
		}
		orders = append(orders, n)
	}
	for _, n := range names {
		dfs(n)
	}
	return orders
}

// generateTypeContent generates GraphQL type definitions for a given struct with tracking context
// This is a shared helper used by all generation strategies
func (g *Generator) generateTypeContent(typeName string, typeSpec *ast.TypeSpec, d StructDirectives, ctx *GenerationContext) string {
	buf := strings.Builder{}

	// Generate all types from @gqlType directives
	if d.HasTypeDirective {
		slog.Debug("Generating type from directive", "type", typeName, "count", len(d.Types))
		for _, typeDef := range d.Types {
			typeContent := g.generateTypeFromDef(typeSpec, typeSpec.Type.(*ast.StructType), d, typeDef, ctx)
			if typeContent != "" {
				buf.WriteString(typeContent)
			}
		}
	} else if g.AutoGeneratedTypes[typeName] {
		// Auto-generated type without explicit @gqlType annotation
		slog.Debug("Auto-generating type", "type", typeName)
		defaultTypeDef := TypeDefinition{
			Name:        typeName,
			Description: "",
		}
		typeContent := g.generateTypeFromDef(typeSpec, typeSpec.Type.(*ast.StructType), d, defaultTypeDef, ctx)
		if typeContent != "" {
			buf.WriteString(typeContent)
		}
	}

	return buf.String()
}

// generateInputContent generates GraphQL input definitions for a given struct with tracking context
// This is a shared helper used by all generation strategies
func (g *Generator) generateInputContent(typeName string, typeSpec *ast.TypeSpec, d StructDirectives, ctx *GenerationContext) string {
	buf := strings.Builder{}

	// Generate all inputs from @gqlInput directives
	if d.HasInputDirective {
		slog.Debug("Generating input from directive", "type", typeName, "count", len(d.Inputs))
		for _, inputDef := range d.Inputs {
			inputContent := g.generateInputFromDef(typeSpec, typeSpec.Type.(*ast.StructType), d, inputDef, ctx)
			if inputContent != "" {
				buf.WriteString(inputContent)
			}
		}
	} else if g.AutoGeneratedInputs[typeName] {
		// Auto-generated input without explicit @gqlInput annotation
		slog.Debug("Auto-generating input", "type", typeName)
		defaultInputDef := InputDefinition{
			Name:        typeName + "Input",
			Description: "",
		}
		inputContent := g.generateInputFromDef(typeSpec, typeSpec.Type.(*ast.StructType), d, defaultInputDef, ctx)
		if inputContent != "" {
			buf.WriteString(inputContent)
		}
	}

	return buf.String()
}

// generateByNamespace generates schema files organized by namespace
func (g *Generator) generateByNamespace(orders []string) (map[string]string, error) {
	slog.Info("Generating schema using namespace strategy")
	// Group types, inputs, and enums by namespace
	type namespaceItems struct {
		types  map[string][]TypeDefinition  // typeName -> type definitions
		inputs map[string][]InputDefinition // typeName -> input definitions
		enums  []string                     // enum names
	}

	namespaces := make(map[string]*namespaceItems)

	// Helper to get or create namespace group
	getNamespace := func(ns string) *namespaceItems {
		if ns == "" {
			ns = "_default"
		}
		if namespaces[ns] == nil {
			namespaces[ns] = &namespaceItems{
				types:  make(map[string][]TypeDefinition),
				inputs: make(map[string][]InputDefinition),
				enums:  []string{},
			}
		}
		return namespaces[ns]
	}

	// Group types and inputs by namespace (file-level or directive-level)
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil || g.P.TypeToDecl[typeName] == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Get file-level namespace for this type
		fileNamespace := g.P.TypeNamespaces[typeName]

		// Group types by their namespace (directive-level overrides file-level)
		if d.HasTypeDirective {
			for _, typeDef := range d.Types {
				ns := typeDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}
				nsItems := getNamespace(ns)
				nsItems.types[typeName] = append(nsItems.types[typeName], typeDef)
			}
		} else if g.AutoGeneratedTypes[typeName] {
			// Auto-generated type without explicit @gqlType annotation
			defaultTypeDef := TypeDefinition{
				Name:        typeName,
				Description: "",
				Namespace:   fileNamespace,
			}
			nsItems := getNamespace(fileNamespace)
			nsItems.types[typeName] = append(nsItems.types[typeName], defaultTypeDef)
		}

		// Group inputs by their namespace (directive-level overrides file-level)
		if d.HasInputDirective {
			for _, inputDef := range d.Inputs {
				ns := inputDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}
				nsItems := getNamespace(ns)
				nsItems.inputs[typeName] = append(nsItems.inputs[typeName], inputDef)
			}
		} else if g.AutoGeneratedInputs[typeName] {
			// Auto-generated input without explicit @gqlInput annotation
			defaultInputDef := InputDefinition{
				Name:        typeName + "Input",
				Description: "",
				Namespace:   fileNamespace,
			}
			nsItems := getNamespace(fileNamespace)
			nsItems.inputs[typeName] = append(nsItems.inputs[typeName], defaultInputDef)
		}
	}

	// Group enums by namespace
	for _, enumName := range g.P.EnumNames {
		ns := g.P.EnumNamespaces[enumName]
		nsItems := getNamespace(ns)
		nsItems.enums = append(nsItems.enums, enumName)
	}

	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Generate content for each namespace
	for namespace, items := range namespaces {
		var outFile string

		if namespace == "_default" {
			// Types without namespace go to default location
			outFile = filepath.Join(g.Config.Output, g.Config.OutputFileName)
		} else {
			// Convert namespace to file path using configured separator
			// e.g., "user/auth" with separator "/" becomes "user/auth.graphqls"
			namespacePath := namespace
			if g.Config.NamespaceSeparator != "/" {
				namespacePath = strings.ReplaceAll(namespace, g.Config.NamespaceSeparator, string(filepath.Separator))
			}
			outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
		}

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating buffer for namespace file", "file", outFile, "namespace", namespace)
		}

		// Create generation context for this namespace file
		ctx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "namespace",
			Namespace:  namespace,
		}

		// Generate enums for this namespace
		slog.Debug("Generating enums for namespace", "namespace", namespace, "count", len(items.enums))
		for _, enumName := range items.enums {
			enumType := g.P.EnumTypes[enumName]
			if enumType == nil {
				continue
			}
			enumContent := g.generateEnum(enumType, ctx)
			if enumContent != "" {
				buf.WriteString(enumContent)
				buf.WriteString("\n")
			}
		}

		// Generate types and inputs for this namespace
		slog.Debug("Generating types for namespace", "namespace", namespace, "count", len(items.types))

		// Context already created above

		// Sort type names for deterministic output
		typeNames := make([]string, 0, len(items.types))
		for typeName := range items.types {
			typeNames = append(typeNames, typeName)
		}
		sort.Strings(typeNames)

		for _, typeName := range typeNames {
			typeDefs := items.types[typeName]
			typeSpec := g.P.StructTypes[typeName]
			structType := typeSpec.Type.(*ast.StructType)
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, typeDef := range typeDefs {
				typeContent := g.generateTypeFromDef(typeSpec, structType, d, typeDef, ctx)
				if typeContent != "" {
					buf.WriteString(typeContent)
				}
			}
		} // Generate inputs for this namespace
		slog.Debug("Generating inputs for namespace", "namespace", namespace, "count", len(items.inputs))
		for typeName, inputDefs := range items.inputs {
			typeSpec := g.P.StructTypes[typeName]
			structType := typeSpec.Type.(*ast.StructType)
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, inputDef := range inputDefs {
				inputContent := g.generateInputFromDef(typeSpec, structType, d, inputDef, ctx)
				if inputContent != "" {
					buf.WriteString(inputContent)
				}
			}
		}
	}

	// After all types have been processed, generate concrete types from generic instantiations
	if err := g.generateConcreteTypesFromInstantiations(); err != nil {
		return nil, err
	}

	// Add concrete type contents to their respective files
	slog.Debug("Adding concrete types to files", "count", len(g.ConcreteTypeContents))
	for typeName, content := range g.ConcreteTypeContents {
		// Find which file this concrete type should go to
		// For now, check the registered item to see which output file it was assigned
		var targetFile string
		for _, item := range g.GeneratedItems {
			if item.GoTypeName == typeName && item.GQLKind == "type" {
				targetFile = item.OutputFile
				slog.Debug("Found target file for concrete type",
					"typeName", typeName,
					"targetFile", targetFile)
				break
			}
		}

		if targetFile != "" {
			buf := fileContents[targetFile]
			if buf != nil {
				buf.WriteString(content)
				slog.Debug("Added concrete type content", "typeName", typeName)
			} else {
				slog.Warn("Buffer not found for target file", "typeName", typeName, "targetFile", targetFile)
			}
		} else {
			slog.Warn("No target file found for concrete type", "typeName", typeName)
		}
	} // Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

// generateByNamespaceAndPackage combines namespace and package strategies
// Types with namespaces use namespace, types without use package directory
func (g *Generator) generateByNamespaceAndPackage(orders []string) (map[string]string, error) {
	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Helper to get or create buffer for a file
	getBuffer := func(filePath string) *strings.Builder {
		buf, exists := fileContents[filePath]
		if !exists {
			buf = &strings.Builder{}
			fileContents[filePath] = buf
		}
		return buf
	}

	// Process enums
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}

		var outFile string
		ns := g.P.EnumNamespaces[enumName]

		if ns != "" {
			// Use namespace
			namespacePath := ns
			if g.Config.NamespaceSeparator != "/" {
				namespacePath = strings.ReplaceAll(ns, g.Config.NamespaceSeparator, string(filepath.Separator))
			}
			outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
		} else {
			// Use package directory
			filePath := g.P.PackagePaths[enumName]
			pkgDir := filepath.Dir(filePath)
			pkgName := filepath.Base(pkgDir)
			outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
		}

		if g.Config.SkipExisting && FileExists(outFile) {
			continue
		}

		buf := getBuffer(outFile)
		// Create context for this namespace/package file
		enumCtx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "namespace+package",
			Namespace:  ns,
		}
		enumContent := g.generateEnum(enumType, enumCtx)
		if enumContent != "" {
			buf.WriteString(enumContent)
			buf.WriteString("\n")
		}
	}

	// Process types and inputs
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Skip if no directives present
		if !d.HasTypeDirective && !d.HasInputDirective {
			continue
		}

		// Get file-level namespace for this type
		fileNamespace := g.P.TypeNamespaces[typeName]

		// Process types
		if d.HasTypeDirective {
			for _, typeDef := range d.Types {
				var outFile string
				ns := typeDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}

				if ns != "" {
					// Use namespace
					namespacePath := ns
					if g.Config.NamespaceSeparator != "/" {
						namespacePath = strings.ReplaceAll(ns, g.Config.NamespaceSeparator, string(filepath.Separator))
					}
					outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
				} else {
					// Use package directory
					filePath := g.P.PackagePaths[typeName]
					pkgDir := filepath.Dir(filePath)
					pkgName := filepath.Base(pkgDir)
					outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
				}

				if g.Config.SkipExisting && FileExists(outFile) {
					continue
				}

				buf := getBuffer(outFile)
				// Create context for this namespace+package file
				ctx := &GenerationContext{
					OutputFile: outFile,
					Strategy:   "namespace+package",
					Namespace:  ns,
				}
				typeContent := g.generateTypeFromDef(typeSpec, typeSpec.Type.(*ast.StructType), d, typeDef, ctx)
				if typeContent != "" {
					buf.WriteString(typeContent)
				}
			}
		}

		// Process inputs
		if d.HasInputDirective {
			for _, inputDef := range d.Inputs {
				var outFile string
				ns := inputDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}

				if ns != "" {
					// Use namespace
					namespacePath := ns
					if g.Config.NamespaceSeparator != "/" {
						namespacePath = strings.ReplaceAll(ns, g.Config.NamespaceSeparator, string(filepath.Separator))
					}
					outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
				} else {
					// Use package directory
					filePath := g.P.PackagePaths[typeName]
					pkgDir := filepath.Dir(filePath)
					pkgName := filepath.Base(pkgDir)
					outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
				}

				if g.Config.SkipExisting && FileExists(outFile) {
					continue
				}

				buf := getBuffer(outFile)
				// Create context for this namespace+package file
				ctx := &GenerationContext{
					OutputFile: outFile,
					Strategy:   "namespace+package",
					Namespace:  ns,
				}
				inputContent := g.generateInputFromDef(typeSpec, typeSpec.Type.(*ast.StructType), d, inputDef, ctx)
				if inputContent != "" {
					buf.WriteString(inputContent)
				}
			}
		}
	}

	// Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

func (g *Generator) generateSingleFile(orders []string) (map[string]string, error) {
	slog.Info("Generating single schema file")

	// Determine output file path
	// If Output ends with an extension (old style), use it directly
	// If Output is a directory (new style), join with OutputFileName
	var outFile string
	if strings.HasSuffix(g.Config.Output, ".graphqls") || strings.HasSuffix(g.Config.Output, ".graphql") || strings.HasSuffix(g.Config.Output, ".gql") {
		// Old style: Output is the full file path
		outFile = g.Config.Output
	} else {
		// New style: Output is directory, use OutputFileName
		outFile = filepath.Join(g.Config.Output, g.Config.OutputFileName)
	}

	if g.Config.SkipExisting && FileExists(outFile) {
		slog.Info("Skipping existing file", "file", outFile)
		fmt.Println("skip", outFile)
		return map[string]string{}, nil
	}

	slog.Debug("Output file", "path", outFile)
	buf := strings.Builder{}
	// Add code generation notice
	//buf.WriteString("# Code generated by https://github.com/pablor21/gqlschemagen, DO NOT EDIT.\n\n")

	// Create generation context for single file strategy
	ctx := &GenerationContext{
		OutputFile: outFile,
		Strategy:   "single",
		Namespace:  "",
	}

	// Generate enums first
	slog.Debug("Generating enums", "count", len(g.P.EnumNames))
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}
		enumContent := g.generateEnum(enumType, ctx)
		if enumContent != "" {
			buf.WriteString(enumContent)
			buf.WriteString("\n")
		}
	}

	slog.Debug("Generating types and inputs", "count", len(orders))
	// Context already created above
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil || g.P.TypeToDecl[typeName] == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Use shared helper functions to generate types and inputs with context
		buf.WriteString(g.generateTypeContent(typeName, typeSpec, d, ctx))
		buf.WriteString(g.generateInputContent(typeName, typeSpec, d, ctx))
	}

	return map[string]string{outFile: buf.String()}, nil
}

func (g *Generator) generatePackageFiles(orders []string) (map[string]string, error) {
	slog.Info("Generating schema files by package")

	// Group types, inputs, and enums by their Go package path
	type packageItems struct {
		types  map[string][]TypeDefinition  // typeName -> type definitions
		inputs map[string][]InputDefinition // typeName -> input definitions
		enums  []string                     // enum names
	}

	packages := make(map[string]*packageItems)

	// Helper to get or create package group
	getPackage := func(pkgPath string) *packageItems {
		if pkgPath == "" {
			pkgPath = "_default"
		}
		if packages[pkgPath] == nil {
			packages[pkgPath] = &packageItems{
				types:  make(map[string][]TypeDefinition),
				inputs: make(map[string][]InputDefinition),
				enums:  []string{},
			}
		}
		return packages[pkgPath]
	}

	// Group enums by package
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}
		// Get package directory from file path in PackagePaths
		filePath := g.P.PackagePaths[enumName]
		pkgDir := filepath.Dir(filePath)
		pkg := getPackage(pkgDir)
		pkg.enums = append(pkg.enums, enumName)
	}

	// Group types and inputs by package
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Get package directory from file path in PackagePaths
		filePath := g.P.PackagePaths[typeName]
		pkgDir := filepath.Dir(filePath)
		pkg := getPackage(pkgDir)

		// Add types
		if d.HasTypeDirective {
			pkg.types[typeName] = append(pkg.types[typeName], d.Types...)
		} else if g.AutoGeneratedTypes[typeName] {
			// Auto-generated type without explicit @gqlType annotation
			defaultTypeDef := TypeDefinition{
				Name:        typeName,
				Description: "",
			}
			pkg.types[typeName] = append(pkg.types[typeName], defaultTypeDef)
		}

		// Add inputs
		if d.HasInputDirective {
			pkg.inputs[typeName] = append(pkg.inputs[typeName], d.Inputs...)
		} else if g.AutoGeneratedInputs[typeName] {
			// Auto-generated input without explicit @gqlInput annotation
			defaultInputDef := InputDefinition{
				Name:        typeName + "Input",
				Description: "",
			}
			pkg.inputs[typeName] = append(pkg.inputs[typeName], defaultInputDef)
		}
	}

	// Sort package paths for deterministic output
	pkgPaths := make([]string, 0, len(packages))
	for pkgPath := range packages {
		pkgPaths = append(pkgPaths, pkgPath)
	}
	sort.Strings(pkgPaths)

	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Generate content for each package
	for _, pkgPath := range pkgPaths {
		items := packages[pkgPath]

		// Determine output file name from package path
		var outFile string
		if pkgPath == "_default" {
			// Types without package go to default location
			outFile = filepath.Join(g.Config.Output, g.Config.OutputFileName)
		} else {
			// Use the last segment of the package path as the file name
			// e.g., "/path/to/models" -> "models.graphqls"
			pkgName := filepath.Base(pkgPath)
			// Remove .go extension if present
			pkgName = strings.TrimSuffix(pkgName, ".go")
			outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
		}

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating buffer for package file", "file", outFile, "package", pkgPath)
		}

		// Create generation context for this package file
		ctx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "package",
			Namespace:  "",
		}

		// Generate enums for this package
		slog.Debug("Generating enums for package", "package", pkgPath, "count", len(items.enums))
		for _, enumName := range items.enums {
			enumType := g.P.EnumTypes[enumName]
			if enumType == nil {
				continue
			}
			enumContent := g.generateEnum(enumType, ctx)
			if enumContent != "" {
				buf.WriteString(enumContent)
				buf.WriteString("\n")
			}
		}

		// Generate types and inputs for this package
		slog.Debug("Generating types for package", "package", pkgPath, "count", len(items.types))

		// Context already created above

		// Sort type names for deterministic output
		typeNames := make([]string, 0, len(items.types))
		for typeName := range items.types {
			typeNames = append(typeNames, typeName)
		}
		sort.Strings(typeNames)

		for _, typeName := range typeNames {
			typeDefs := items.types[typeName]
			typeSpec := g.P.StructTypes[typeName]
			structType := typeSpec.Type.(*ast.StructType)
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, typeDef := range typeDefs {
				typeContent := g.generateTypeFromDef(typeSpec, structType, d, typeDef, ctx)
				if typeContent != "" {
					buf.WriteString(typeContent)
				}
			}
		} // Generate inputs for this package
		slog.Debug("Generating inputs for package", "package", pkgPath, "count", len(items.inputs))
		for typeName, inputDefs := range items.inputs {
			typeSpec := g.P.StructTypes[typeName]
			structType := typeSpec.Type.(*ast.StructType)
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, inputDef := range inputDefs {
				inputContent := g.generateInputFromDef(typeSpec, structType, d, inputDef, ctx)
				if inputContent != "" {
					buf.WriteString(inputContent)
				}
			}
		}
	}

	// Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

func (g *Generator) generateMultipleFiles(orders []string) (map[string]string, error) {
	slog.Info("Generating multiple schema files (one per type)")

	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Generate enums first
	slog.Debug("Generating enum files", "count", len(g.P.EnumNames))
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}

		fileName := strings.ToLower(enumName) + g.Config.OutputFileExtension
		outFile := filepath.Join(g.Config.Output, fileName)

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating file for enum", "file", outFile, "enum", enumName)
		}

		// Create generation context for this enum file
		enumCtx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "multiple",
			Namespace:  "",
		}

		enumContent := g.generateEnum(enumType, enumCtx)
		if enumContent != "" {
			buf.WriteString(enumContent)
		}
	}

	// Generate types and inputs
	slog.Debug("Generating type and input files", "count", len(orders))
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Skip if no directives present and not auto-generated
		if !d.HasTypeDirective && !d.HasInputDirective && !g.AutoGeneratedTypes[typeName] && !g.AutoGeneratedInputs[typeName] {
			continue
		}

		// Generate filename
		fileName := g.resolveFileName(d, typeSpec.Name.Name)
		outFile := filepath.Join(g.Config.Output, fileName)

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating file for type", "file", outFile, "type", typeName)
		}

		// Create generation context for this file
		ctx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "multiple",
			Namespace:  "",
		}

		// Use shared helper functions to generate types and inputs with context
		buf.WriteString(g.generateTypeContent(typeName, typeSpec, d, ctx))
		buf.WriteString(g.generateInputContent(typeName, typeSpec, d, ctx))
	}

	// Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

func (g *Generator) resolveFileName(d StructDirectives, typeName string) string {
	pattern := g.Config.SchemaFileName
	if pattern == "" {
		pattern = "{model_name}.graphqls"
	}

	modelName := strings.ToLower(d.GQLName)
	pattern = strings.ReplaceAll(pattern, "{model_name}", modelName)
	pattern = strings.ReplaceAll(pattern, "{type_name}", typeName)

	return pattern
}

// writeGoModelDirective writes the @goModel directive if enabled
func (g *Generator) writeGoModelDirective(buf *strings.Builder, goTypeName string, useDirective bool) {
	if g.Config.UseGqlGenDirectives || useDirective {
		pkgPath := g.P.GetPackageImportPath(goTypeName, g.Config.ModelPath)
		fmt.Fprintf(buf, " @goModel(model: \"%s.%s\")", pkgPath, goTypeName)
	}
}

// writeGoFieldDirective writes the @goField(forceResolver: true) directive if enabled
func (g *Generator) writeGoFieldDirective(buf *strings.Builder, forceResolver bool) {
	if g.Config.UseGqlGenDirectives && forceResolver {
		buf.WriteString(" @goField(forceResolver: true)")
	}
}

// writeDeprecatedDirective writes the @deprecated directive with optional reason
func (g *Generator) writeDeprecatedDirective(buf *strings.Builder, deprecated bool, reason string) {
	if !deprecated {
		return
	}
	if reason != "" {
		// Escape quotes in the reason
		escapedReason := strings.ReplaceAll(reason, `"`, `\"`)
		fmt.Fprintf(buf, ` @deprecated(reason: "%s")`, escapedReason)
	} else {
		buf.WriteString(" @deprecated")
	}
}

// writeGoEnumDirective writes the @goEnum directive if enabled
func (g *Generator) writeGoEnumDirective(buf *strings.Builder, valuePkgPath string, valueGoName string) {
	if g.Config.UseGqlGenDirectives {
		fmt.Fprintf(buf, " @goEnum(value: \"%s.%s\")", valuePkgPath, valueGoName)
	}
}

// generateTypeFromDef generates a GraphQL type from a specific TypeDefinition
// generateTypeFromDef generates a GraphQL type with generation context for tracking
func (g *Generator) generateTypeFromDef(typeSpec *ast.TypeSpec, st *ast.StructType, d StructDirectives, typeDef TypeDefinition, ctx *GenerationContext) string {
	typeName := typeSpec.Name.Name
	name := d.GQLName
	if typeDef.Name != "" {
		// Use custom type name from @gqlType annotation
		name = typeDef.Name
	} else {
		// Apply prefix/suffix stripping only when no custom name is specified
		name = StripPrefixSuffix(name, g.Config.StripPrefix, g.Config.StripSuffix)
		// Apply prefix/suffix addition
		if g.Config.AddTypePrefix != "" {
			name = g.Config.AddTypePrefix + name
		}
		if g.Config.AddTypeSuffix != "" {
			name = name + g.Config.AddTypeSuffix
		}
	}

	buf := strings.Builder{}

	// Add description if present
	if typeDef.Description != "" {
		buf.WriteString(fmt.Sprintf("\"\"\"%s\"\"\"\n", typeDef.Description))
	}

	// Type declaration
	buf.WriteString(fmt.Sprintf("type %s", name))

	// Add @goModel directive if enabled
	g.writeGoModelDirective(&buf, typeSpec.Name.Name, d.UseModelDirective)

	buf.WriteString(" {\n")

	// Ensure context has TypeSubstitutions initialized
	if ctx.TypeSubstitutions == nil {
		ctx.TypeSubstitutions = make(map[string]ast.Expr)
	}

	// Generate fields from struct (use typeDef.IgnoreAll instead of d.TypeIgnoreAll)
	fields := g.generateFieldsForTypeNamed(st, d, typeDef.IgnoreAll, false, name, ctx)

	// Count applicable extra fields for this type
	applicableExtraFields := 0
	for _, ef := range d.TypeExtraFields {
		if shouldApplyExtraField(ef, name) {
			applicableExtraFields++
		}
	}

	if len(fields) == 0 && applicableExtraFields == 0 && !g.Config.IncludeEmptyTypes {
		return "" // Skip empty types
	}

	buf.WriteString(fields)

	// Add extra fields from @gqlTypeExtraField annotations
	for _, ef := range d.TypeExtraFields {
		// Check if this field applies to this type
		if !shouldApplyExtraField(ef, name) {
			continue
		}
		if ef.Description != "" {
			buf.WriteString(fmt.Sprintf("\t\"\"\"%s\"\"\"\n", ef.Description))
		}
		buf.WriteString(fmt.Sprintf("\t%s: %s", ef.Name, ef.Type))
		g.writeGoFieldDirective(&buf, true)
		buf.WriteString("\n")
	}

	buf.WriteString("}\n\n")

	// Register generated item
	pkgPath := g.P.GetPackageImportPath(typeName, g.Config.ModelPath)
	g.registerGeneratedItem(GQLSchemaItem{
		OutputFile:    ctx.OutputFile,
		GoSourceFile:  g.P.SourceFiles[typeName],
		GoType:        pkgPath + "." + typeName,
		GoTypeName:    typeName,
		GQLName:       name,
		GQLKind:       "type",
		Strategy:      ctx.Strategy,
		AutoGenerated: g.AutoGeneratedTypes[typeName],
		Namespace:     ctx.Namespace,
	})

	return buf.String()
}

// generateInputFromDef generates a GraphQL input from a specific InputDefinition
// generateInputFromDef generates a GraphQL input with generation context for tracking
func (g *Generator) generateInputFromDef(typeSpec *ast.TypeSpec, st *ast.StructType, d StructDirectives, inputDef InputDefinition, ctx *GenerationContext) string {
	typeName := typeSpec.Name.Name
	inputName := inputDef.Name
	if inputName == "" {
		// Apply prefix/suffix stripping before adding "Input" suffix
		baseName := StripPrefixSuffix(d.GQLName, g.Config.StripPrefix, g.Config.StripSuffix)

		// For auto-generated inputs, check if the type name already ends with "Input"
		// to avoid CreateUserInput -> CreateUserInputInput
		if !strings.HasSuffix(baseName, "Input") {
			inputName = baseName + "Input"
		} else {
			inputName = baseName
		}

		// Apply prefix/suffix addition
		if g.Config.AddInputPrefix != "" {
			inputName = g.Config.AddInputPrefix + inputName
		}
		if g.Config.AddInputSuffix != "" {
			inputName = inputName + g.Config.AddInputSuffix
		}
	}

	buf := strings.Builder{}

	// Add description if present
	if inputDef.Description != "" {
		buf.WriteString(fmt.Sprintf("\"\"\"%s\"\"\"\n", inputDef.Description))
	}

	// Input declaration
	buf.WriteString(fmt.Sprintf("input %s", inputName))

	// Add @goModel directive if enabled
	g.writeGoModelDirective(&buf, typeSpec.Name.Name, d.UseModelDirective)

	buf.WriteString(" {\n")

	// Ensure context has TypeSubstitutions initialized
	if ctx.TypeSubstitutions == nil {
		ctx.TypeSubstitutions = make(map[string]ast.Expr)
	}

	// Generate fields from struct (use inputDef.IgnoreAll instead of d.InputIgnoreAll)
	fields := g.generateFieldsForTypeNamed(st, d, inputDef.IgnoreAll, true, inputName, ctx)

	// Count applicable extra fields for this input
	applicableExtraFields := 0
	for _, ef := range d.InputExtraFields {
		if shouldApplyExtraField(ef, inputName) {
			applicableExtraFields++
		}
	}

	if len(fields) == 0 && applicableExtraFields == 0 && !g.Config.IncludeEmptyTypes {
		return "" // Skip empty inputs
	}

	buf.WriteString(fields)

	// Add extra fields from @gqlInputExtraField annotations
	for _, ef := range d.InputExtraFields {
		// Check if this field applies to this input
		if !shouldApplyExtraField(ef, inputName) {
			continue
		}
		if ef.Description != "" {
			buf.WriteString(fmt.Sprintf("\t\"\"\"%s\"\"\"\n", ef.Description))
		}
		buf.WriteString(fmt.Sprintf("\t%s: %s\n", ef.Name, ef.Type))
	}

	buf.WriteString("}\n\n")

	// Register generated item
	pkgPath := g.P.GetPackageImportPath(typeName, g.Config.ModelPath)
	g.registerGeneratedItem(GQLSchemaItem{
		OutputFile:    ctx.OutputFile,
		GoSourceFile:  g.P.SourceFiles[typeName],
		GoType:        pkgPath + "." + typeName,
		GoTypeName:    typeName,
		GQLName:       inputName,
		GQLKind:       "input",
		Strategy:      ctx.Strategy,
		AutoGenerated: g.AutoGeneratedInputs[typeName],
		Namespace:     ctx.Namespace,
	})

	return buf.String()
}

// generateFieldsForType generates fields with specific ignoreAll setting
// func (g *Generator) generateFieldsForType(st *ast.StructType, d StructDirectives, typeIgnoreAll bool, forInput bool) string {
// 	return g.generateFieldsForTypeNamed(st, d, typeIgnoreAll, forInput, "")
// }

// generateFieldsForTypeNamed generates fields with specific ignoreAll setting and type/input name for filtering
func (g *Generator) generateFieldsForTypeNamed(st *ast.StructType, d StructDirectives, typeIgnoreAll bool, forInput bool, typeName string, ctx *GenerationContext) string {
	buf := strings.Builder{}

	// Determine which ignoreAll flag to use
	ignoreAll := d.IgnoreAll || typeIgnoreAll

	for _, f := range st.Fields.List {
		// Handle embedded fields
		if f.Names == nil {
			// This is an embedded field - expand its fields with context
			embeddedFields := g.expandEmbeddedFieldNamed(f, d, ignoreAll, forInput, typeName, ctx)
			buf.WriteString(embeddedFields)
			continue
		}

		opt := ParseFieldOptions(f, g.Config)

		// Determine if field should be included using new type-specific logic
		include := shouldIncludeField(opt, ignoreAll, forInput, typeName)
		if !include {
			continue
		}

		// Check if this field's type is a type parameter that resolves to a generic instantiation
		// If so, treat it as an embedded field to recursively expand the nested generic
		if ident, ok := f.Type.(*ast.Ident); ok {
			if ctx != nil && ctx.TypeSubstitutions != nil {
				if substituted, exists := ctx.TypeSubstitutions[ident.Name]; exists {
					// Check if the substitution is a generic instantiation
					if g.isGenericInstantiationExpr(substituted) {
						// Create a synthetic embedded field with the substituted type
						syntheticField := &ast.Field{
							Names: nil, // No names = embedded field
							Type:  substituted,
						}
						embeddedFields := g.expandEmbeddedFieldNamed(syntheticField, d, ignoreAll, forInput, typeName, ctx)
						buf.WriteString(embeddedFields)
						continue
					}
				}
			}
		}

		// Resolve field name
		fieldName := opt.Name
		if fieldName == "" {
			fieldName = ResolveFieldName(f, g.Config)
		}

		// Resolve field type with context for type parameter substitution
		fieldType := opt.Type
		if fieldType == "" {
			if forInput {
				// For inputs, convert type references to input references with context
				fieldType = ExprToGraphQLTypeForInputWithContext(f.Type, g.Config.KnownScalars, g.P.EnumTypes, g.Config, ctx, g)
			} else {
				fieldType = ExprToGraphQLTypeWithContext(f.Type, g.Config, ctx, g)
			}
		}

		// Check if field type is out of scope (if no custom type was specified)
		if opt.Type == "" {
			baseTypeName := g.extractBaseTypeName(fieldType)
			if baseTypeName != "" && !g.isTypeInScope(baseTypeName) {
				// Check if we should suppress warnings for type parameters
				if g.Config.AutoGenerate.SuppressGenericTypeWarnings && g.isTypeParameter(baseTypeName) {
					// Skip adding to OutOfScopeTypes - it's just a type parameter
					// Continue to next step without logging warning
				} else {
					// Get the Go field name and type from AST
					goFieldName := f.Names[0].Name
					goFieldType := ExprToGoType(f.Type)

					// Determine parent GQL name (could be type or input)
					parentGQLName := typeName
					if forInput {
						// For inputs, we need to find the actual input name being generated
						// typeName is the input name passed to generateFieldsForTypeNamed
						parentGQLName = typeName
					}

					ref := OutOfScopeReference{
						ParentGoType:   typeName,
						ParentGQLName:  parentGQLName,
						GoFieldName:    goFieldName,
						FieldName:      fieldName,
						GoFieldType:    goFieldType,
						ReferencedType: baseTypeName,
					}
					g.OutOfScopeTypes[baseTypeName] = append(g.OutOfScopeTypes[baseTypeName], ref) // Handle based on configuration
					switch g.Config.AutoGenerate.OutOfScopeTypes {
					case OutOfScopeExclude:
						// Skip this field - don't include in schema
						continue
					case OutOfScopeFail:
						// Include field but error will be reported at end
						// Don't continue - let field be added to schema
					case OutOfScopeIgnore:
						// Continue with the field as-is
					case OutOfScopeWarn:
						// Continue with the field, warning will be logged later
					}
				}
			}
		}

		// Handle optional/required
		if opt.Optional {
			fieldType = strings.TrimSuffix(fieldType, "!")
		} else if opt.Required && !strings.HasSuffix(fieldType, "!") {
			fieldType = fieldType + "!"
		}

		// Add field with description if present
		if opt.Description != "" {
			buf.WriteString(fmt.Sprintf("    \"\"\"%s\"\"\"\n", opt.Description))
		}

		buf.WriteString(fmt.Sprintf("    %s: %s", fieldName, fieldType))

		// Add @goField directive if forceResolver is set
		g.writeGoFieldDirective(&buf, opt.ForceResolver)

		// Add @deprecated directive if field is deprecated
		g.writeDeprecatedDirective(&buf, opt.Deprecated, opt.DeprecatedReason)
		buf.WriteString("\n")
	}

	return buf.String()
}

// shouldApplyExtraField checks if an extra field should be applied to a given type/input name
// based on the 'on' filter. Returns true if:
// - On is empty (no filter specified, defaults to all)
// - On contains "*" (explicitly apply to all)
// - On contains the targetName
func shouldApplyExtraField(ef ExtraField, targetName string) bool {
	if len(ef.On) == 0 {
		return true
	}
	for _, name := range ef.On {
		if name == "*" || name == targetName {
			return true
		}
	}
	return false
}

// shouldIncludeField determines if a field should be included in a type/input
// based on the FieldOptions and context (forInput, typeName)
func shouldIncludeField(opt FieldOptions, ignoreAll bool, forInput bool, typeName string) bool {
	// Handle read-only (ro): include only in types, ignore in inputs
	if len(opt.ReadOnly) > 0 {
		if forInput {
			return false // Exclude from inputs
		}
		// Include in types only if typeName matches or is *
		return matchesTypeList(opt.ReadOnly, typeName)
	}

	// Handle write-only (wo): include only in inputs, ignore in types
	if len(opt.WriteOnly) > 0 {
		if !forInput {
			return false // Exclude from types
		}
		// Include in inputs only if typeName matches or is *
		return matchesTypeList(opt.WriteOnly, typeName)
	}

	// Handle read-write (rw): include in both types and inputs
	if len(opt.ReadWrite) > 0 {
		return matchesTypeList(opt.ReadWrite, typeName)
	}

	// Handle ignore/omit list (omit is alias for ignore)
	if len(opt.IgnoreList) > 0 && matchesTypeList(opt.IgnoreList, typeName) {
		return false
	}

	// Handle include list
	if len(opt.IncludeList) > 0 {
		return matchesTypeList(opt.IncludeList, typeName)
	}

	// Legacy behavior: check old boolean flags
	// Include if: (not ignored by ignoreAll AND not explicitly ignored/omitted) OR explicitly included
	return (!ignoreAll && !opt.Ignore && !opt.Omit) || opt.Include
}

// matchesTypeList checks if a typeName matches any entry in the list
// Returns true if list contains "*" or the exact typeName
func matchesTypeList(list []string, typeName string) bool {
	if len(list) == 0 {
		return false
	}
	for _, name := range list {
		if name == "*" || name == typeName {
			return true
		}
	}
	return false
}

// expandEmbeddedField recursively expands an embedded struct field into GraphQL fields
// func (g *Generator) expandEmbeddedField(f *ast.Field, d StructDirectives, ignoreAll bool, forInput bool) string {
// 	return g.expandEmbeddedFieldNamed(f, d, ignoreAll, forInput, "")
// }

// expandEmbeddedFieldNamed recursively expands an embedded struct field into GraphQL fields with type name and context
func (g *Generator) expandEmbeddedFieldNamed(f *ast.Field, d StructDirectives, ignoreAll bool, forInput bool, typeName string, ctx *GenerationContext) string {
	// Get the type name of the embedded field and build type substitutions
	var embeddedTypeName string

	// Create a NEW context with type substitutions for this embedded scope
	embeddedCtx := &GenerationContext{
		OutputFile:        ctx.OutputFile,
		Strategy:          ctx.Strategy,
		Namespace:         ctx.Namespace,
		TypeSubstitutions: make(map[string]ast.Expr),
	}

	// Copy parent substitutions (for nested generics)
	for k, v := range ctx.TypeSubstitutions {
		embeddedCtx.TypeSubstitutions[k] = v
	}

	switch t := f.Type.(type) {
	case *ast.Ident:
		embeddedTypeName = t.Name
	case *ast.StarExpr:
		// Handle pointer to embedded struct or generic
		switch x := t.X.(type) {
		case *ast.Ident:
			embeddedTypeName = x.Name
		case *ast.IndexExpr:
			// Handle pointer to generic type with single param (e.g., *Repository[Post])
			embeddedTypeName = g.extractGenericBaseName(x.X)
			if typeParams, ok := g.P.TypeParameters[embeddedTypeName]; ok && len(typeParams) > 0 {
				resolvedArg := g.resolveTypeArgument(x.Index, ctx)
				embeddedCtx.TypeSubstitutions[typeParams[0]] = resolvedArg
			}
		case *ast.IndexListExpr:
			// Handle pointer to generic type with multiple params (e.g., *Map[K, V])
			embeddedTypeName = g.extractGenericBaseName(x.X)
			if typeParams, ok := g.P.TypeParameters[embeddedTypeName]; ok {
				for i, paramName := range typeParams {
					if i < len(x.Indices) {
						resolvedArg := g.resolveTypeArgument(x.Indices[i], ctx)
						embeddedCtx.TypeSubstitutions[paramName] = resolvedArg
					}
				}
			}
		}
	case *ast.SelectorExpr:
		// Handle embedded struct from another package (e.g., pkg.Type)
		embeddedTypeName = t.Sel.Name
	case *ast.IndexExpr:
		// Handle generic type with single type parameter (e.g., Result[*User])
		embeddedTypeName = g.extractGenericBaseName(t.X)

		// Look up type parameters for this generic type and build substitutions
		if typeParams, ok := g.P.TypeParameters[embeddedTypeName]; ok && len(typeParams) > 0 {
			// First resolve the argument through parent context if it's a type parameter
			resolvedArg := g.resolveTypeArgument(t.Index, ctx)
			// Map first type param (e.g., T) to the resolved type argument (e.g., *User)
			embeddedCtx.TypeSubstitutions[typeParams[0]] = resolvedArg
		}

	case *ast.IndexListExpr:
		// Handle generic type with multiple type parameters (e.g., Map[string, *Setting])
		embeddedTypeName = g.extractGenericBaseName(t.X)

		// Look up type parameters and map each to its corresponding argument
		if typeParams, ok := g.P.TypeParameters[embeddedTypeName]; ok {
			for i, paramName := range typeParams {
				if i < len(t.Indices) {
					// Resolve each argument through parent context
					resolvedArg := g.resolveTypeArgument(t.Indices[i], ctx)
					embeddedCtx.TypeSubstitutions[paramName] = resolvedArg
				}
			}
		}
	}

	if embeddedTypeName == "" {
		return "" // Unable to determine type name
	}

	// Look up the embedded struct in the parser
	typeSpec, exists := g.P.StructTypes[embeddedTypeName]
	if !exists {
		return "" // Embedded struct not found in parsed types
	}
	embeddedStruct, ok := typeSpec.Type.(*ast.StructType)
	if !ok {
		return "" // Not a struct type
	}

	// If generating for input and the embedded type should be auto-generated as input,
	// mark it for generation
	if forInput {
		if typeSpec != nil {
			genDecl := g.P.TypeToDecl[embeddedTypeName]
			directives := ParseDirectives(typeSpec, genDecl)
			if !directives.HasInputDirective && !directives.SkipType {
				g.AutoGeneratedInputs[embeddedTypeName] = true
			}
		}
	}

	// Recursively generate fields for the embedded struct with the NEW context that has substitutions
	// Create a minimal StructDirectives for the embedded type (no special directives)
	embeddedDirectives := StructDirectives{
		IgnoreAll: ignoreAll, // Inherit ignoreAll setting
	}

	return g.generateFieldsForTypeNamed(embeddedStruct, embeddedDirectives, false, forInput, typeName, embeddedCtx)
}

// generateConcreteTypesFromInstantiations generates concrete types for tracked generic instantiations
// For example, if Edge[*Comment] was referenced, this generates a CommentEdge type
func (g *Generator) generateConcreteTypesFromInstantiations() error {
	slog.Info("Generating concrete types from instantiations", "count", len(g.GenericInstantiations))

	for concreteTypeName, inst := range g.GenericInstantiations {
		slog.Debug("Processing concrete type",
			"concreteTypeName", concreteTypeName,
			"genericType", inst.GenericTypeName)
		// Get the generic type's TypeSpec
		typeSpec, exists := g.P.StructTypes[inst.GenericTypeName]
		if !exists {
			// Try with pointer
			typeSpec, exists = g.P.StructTypes["*"+inst.GenericTypeName]
			if !exists {
				slog.Warn("Generic type not found for instantiation",
					"concreteType", concreteTypeName,
					"genericType", inst.GenericTypeName)
				continue
			}
		}

		// typeSpec is *ast.TypeSpec, get the struct type
		st, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			slog.Warn("Generic type is not a struct",
				"concreteType", concreteTypeName,
				"genericType", inst.GenericTypeName)
			continue
		}

		// Build substitution context
		typeSubstitutions := make(map[string]ast.Expr)
		if typeSpec.TypeParams != nil {
			for i, typeParam := range typeSpec.TypeParams.List {
				if i < len(inst.TypeArguments) {
					for _, name := range typeParam.Names {
						typeSubstitutions[name.Name] = inst.TypeArguments[i]
					}
				}
			}
		}

		// Determine namespace from the first type argument
		// e.g., for CommentEdge (Edge[*Comment]), use Comment's namespace
		namespace := ""
		outputFile := g.Config.Output
		if len(inst.TypeArguments) > 0 {
			if argIdent := extractTypeIdentFromExpr(inst.TypeArguments[0]); argIdent != "" {
				if argNamespace, exists := g.P.TypeNamespaces[argIdent]; exists {
					namespace = argNamespace
					// Calculate output file based on namespace
					if namespace != "" {
						namespacePath := namespace
						if g.Config.NamespaceSeparator != "/" {
							namespacePath = strings.ReplaceAll(namespace, g.Config.NamespaceSeparator, string(filepath.Separator))
						}
						outputFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
					} else {
						outputFile = filepath.Join(g.Config.Output, g.Config.OutputFileName)
					}
				}
			}
		}

		// Create generation context for this instantiation
		ctx := &GenerationContext{
			TypeSubstitutions: typeSubstitutions,
			OutputFile:        outputFile,
			Strategy:          string(GenStrategySingle),
			Namespace:         namespace,
		}

		// Generate the GraphQL type content
		content := g.generateConcreteTypeContent(concreteTypeName, typeSpec, st, ctx)
		if content != "" {
			slog.Debug("Generated concrete type from generic instantiation",
				"concreteType", concreteTypeName,
				"genericType", inst.GenericTypeName,
				"typeArgs", len(inst.TypeArguments),
				"namespace", namespace)
		}
	}

	return nil
}

// extractTypeIdentFromExpr extracts the type identifier name from an expression
// Handles *ast.Ident, *ast.StarExpr, and *ast.SelectorExpr
func extractTypeIdentFromExpr(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return extractTypeIdentFromExpr(t.X)
	case *ast.SelectorExpr:
		return t.Sel.Name
	}
	return ""
}

// generateConcreteTypeContent generates GraphQL schema for a concrete generic instantiation
func (g *Generator) generateConcreteTypeContent(typeName string, typeSpec *ast.TypeSpec, st *ast.StructType, ctx *GenerationContext) string {
	var buf strings.Builder

	// Generate type definition
	buf.WriteString(fmt.Sprintf("type %s {\n", typeName))

	// Use existing field generation logic with the substitution context
	// This will handle embedded fields, type substitution, directives, etc.
	d := StructDirectives{} // Empty directives for concrete types
	fields := g.generateFieldsForTypeNamed(st, d, false, false, typeName, ctx)
	buf.WriteString(fields)

	buf.WriteString("}\n\n")

	content := buf.String()

	// Store the content so it can be added to the appropriate output file
	g.ConcreteTypeContents[typeName] = content

	// Register generated item
	pkgPath := g.P.GetPackageImportPath(typeName, g.Config.ModelPath)
	g.registerGeneratedItem(GQLSchemaItem{
		OutputFile:    ctx.OutputFile,
		GoSourceFile:  "", // No direct source file for concrete instantiations
		GoType:        pkgPath + "." + typeName,
		GoTypeName:    typeName,
		GQLName:       typeName,
		GQLKind:       "type",
		Strategy:      ctx.Strategy,
		AutoGenerated: true, // Concrete types are always auto-generated
		Namespace:     ctx.Namespace,
	})

	return content
}

// generateConcreteTypeName generates a concrete type name from a generic instantiation
// For example: Edge[*Comment]  CommentEdge, Repository[Post]  PostRepository
func (g *Generator) generateConcreteTypeName(genericType string, typeArgs []ast.Expr) string {
	if len(typeArgs) == 0 {
		return genericType
	}

	// Extract the main type name from the first type argument
	var argTypeName string
	firstArg := typeArgs[0]

	slog.Debug("Generating concrete type name",
		"genericType", genericType,
		"firstArgType", fmt.Sprintf("%T", firstArg))

	switch t := firstArg.(type) {
	case *ast.Ident:
		argTypeName = t.Name
		slog.Debug("Extracted from Ident", "name", argTypeName)
	case *ast.StarExpr:
		if ident, ok := t.X.(*ast.Ident); ok {
			argTypeName = ident.Name
			slog.Debug("Extracted from StarExpr", "name", argTypeName)
		}
	case *ast.SelectorExpr:
		argTypeName = t.Sel.Name
		slog.Debug("Extracted from SelectorExpr", "name", argTypeName)
	case *ast.IndexExpr:
		argTypeName = g.extractGenericBaseName(t.X)
		slog.Debug("Extracted from IndexExpr", "name", argTypeName)
	case *ast.IndexListExpr:
		argTypeName = g.extractGenericBaseName(t.X)
		slog.Debug("Extracted from IndexListExpr", "name", argTypeName)
	}

	if argTypeName == "" {
		slog.Warn("Failed to extract arg type name, using generic type", "genericType", genericType)
		return genericType
	}

	// Generate name as: ArgType + GenericType (e.g., CommentEdge, PostRepository)
	concreteTypeName := argTypeName + genericType
	slog.Debug("Generated concrete type name", "concreteTypeName", concreteTypeName)
	return concreteTypeName
}

// trackGenericInstantiation tracks a generic instantiation that needs a concrete type generated
func (g *Generator) trackGenericInstantiation(genericType string, typeArgs []ast.Expr, ctx *GenerationContext) string {
	if len(typeArgs) == 0 || genericType == "" {
		return genericType
	}

	// Check if this is actually a generic type we know about
	if _, exists := g.P.TypeParameters[genericType]; !exists {
		return genericType // Not a generic type
	}

	concreteTypeName := g.generateConcreteTypeName(genericType, typeArgs)

	// Check if we've already tracked this instantiation
	if _, exists := g.GenericInstantiations[concreteTypeName]; exists {
		return concreteTypeName
	}

	// Track this instantiation
	g.GenericInstantiations[concreteTypeName] = &GenericInstantiation{
		GenericTypeName:  genericType,
		ConcreteTypeName: concreteTypeName,
		TypeArguments:    typeArgs,
		Context:          ctx,
	}

	// Mark for auto-generation
	g.AutoGeneratedTypes[concreteTypeName] = true

	return concreteTypeName
}

// isGenericInstantiationExpr checks if an expression is a generic type instantiation
// Returns true for any level: Repository[Post], Map[K,V], or nested Connection[Test[X[D]]]
func (g *Generator) isGenericInstantiationExpr(expr ast.Expr) bool {
	switch t := expr.(type) {
	case *ast.IndexExpr, *ast.IndexListExpr:
		return true
	case *ast.StarExpr:
		// Check if it's a pointer to a generic instantiation (*Repository[Post])
		return g.isGenericInstantiationExpr(t.X)
	}
	return false
}

// resolveTypeArgument resolves a type argument expression through the parent context
// This handles nested generics at any depth like Connection[Test[X[D]]] where each level needs resolution
func (g *Generator) resolveTypeArgument(arg ast.Expr, parentCtx *GenerationContext) ast.Expr {
	if parentCtx == nil || parentCtx.TypeSubstitutions == nil {
		return arg
	}

	// If the argument is a simple identifier that exists in parent substitutions, resolve it
	if ident, ok := arg.(*ast.Ident); ok {
		if substituted, exists := parentCtx.TypeSubstitutions[ident.Name]; exists {
			return substituted
		}
	}

	// If it's a pointer to an identifier, check if the base needs resolution
	if starExpr, ok := arg.(*ast.StarExpr); ok {
		if ident, ok := starExpr.X.(*ast.Ident); ok {
			if substituted, exists := parentCtx.TypeSubstitutions[ident.Name]; exists {
				// Return pointer to the substituted type
				return &ast.StarExpr{X: substituted}
			}
		}
	}

	// For other cases (including IndexExpr/IndexListExpr), return as-is
	// The nested generic will be handled when we expand that embedded field
	return arg
}

// extractGenericBaseName extracts the base type name from a generic type expression
// For example: Connection[T] -> "Connection", pkg.Edge[T] -> "Edge"
func (g *Generator) extractGenericBaseName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		// Handle package-qualified generic types (e.g., pkg.Type[T])
		return t.Sel.Name
	case *ast.StarExpr:
		// Handle pointer to generic type (e.g., *Connection[T])
		return g.extractGenericBaseName(t.X)
	}
	return ""
}

// extractBaseTypeName extracts the base type name from a GraphQL type string
// For example: "String!" -> "String", "[User!]!" -> "User", "PageInfo" -> "PageInfo"
func (g *Generator) extractBaseTypeName(graphQLType string) string {
	// Remove all !, [, and ] characters
	cleaned := strings.ReplaceAll(graphQLType, "!", "")
	cleaned = strings.ReplaceAll(cleaned, "[", "")
	cleaned = strings.ReplaceAll(cleaned, "]", "")
	cleaned = strings.TrimSpace(cleaned)

	// Check if it's a known scalar (built-in or custom)
	for _, scalar := range g.Config.KnownScalars {
		if scalar == cleaned {
			return "" // Known scalars are always in scope
		}
	}

	return cleaned
}

// isTypeInScope checks if a type name exists in the parsed types (structs or enums)
// buildScannedTypesRegistry populates the ScannedTypes registry with metadata about all scanned types
func (g *Generator) buildScannedTypesRegistry() {
	for typeName, typeSpec := range g.P.StructTypes {
		if genDecl, hasDecl := g.P.TypeToDecl[typeName]; hasDecl {
			directives := ParseDirectives(typeSpec, genDecl)

			info := &ScannedTypeInfo{
				TypeName:          typeName,
				HasTypeDirective:  directives.HasTypeDirective,
				HasInputDirective: directives.HasInputDirective,
				GeneratedTypes:    make([]string, 0),
				GeneratedInputs:   make([]string, 0),
			}

			// Collect generated type names from @gqlType annotations
			for _, typeDef := range directives.Types {
				if typeDef.Name != "" {
					info.GeneratedTypes = append(info.GeneratedTypes, typeDef.Name)
				} else {
					info.GeneratedTypes = append(info.GeneratedTypes, typeName)
				}
			}

			// Collect generated input names from @gqlInput annotations
			for _, inputDef := range directives.Inputs {
				if inputDef.Name != "" {
					info.GeneratedInputs = append(info.GeneratedInputs, inputDef.Name)
				} else {
					info.GeneratedInputs = append(info.GeneratedInputs, typeName+"Input")
				}
			}

			g.P.ScannedTypes[typeName] = info
		}
	}
}

func (g *Generator) isTypeInScope(typeName string) bool {
	if typeName == "" {
		return true
	}

	// Check if it's a concrete type from a generic instantiation (tracked for auto-generation)
	if _, exists := g.GenericInstantiations[typeName]; exists {
		return true
	}

	// Check if this type name was generated from a scanned type with GQL annotations
	for _, scannedInfo := range g.P.ScannedTypes {
		// Check if typeName matches any generated type names
		for _, genType := range scannedInfo.GeneratedTypes {
			if genType == typeName {
				return true
			}
		}
		// Check if typeName matches any generated input names
		for _, genInput := range scannedInfo.GeneratedInputs {
			if genInput == typeName {
				return true
			}
		}
	}

	// Check if it's a struct type (scanned but no annotations)
	if _, exists := g.P.StructTypes[typeName]; exists {
		return true
	}

	// Check if it's an enum type
	if _, exists := g.P.EnumTypes[typeName]; exists {
		return true
	}

	return false
}

// isTypeParameter checks if a name is likely a generic type parameter
// It checks against known type parameters from parsed generic types and common conventions
func (g *Generator) isTypeParameter(name string) bool {
	// Check if this name is a known type parameter from any parsed generic type
	for _, params := range g.P.TypeParameters {
		for _, param := range params {
			if param == name {
				return true
			}
		}
	}

	// Fallback: check common single-letter type parameters
	commonParams := map[string]bool{
		"T": true, "K": true, "V": true, "E": true,
		"U": true, "R": true, "S": true,
	}
	if commonParams[name] {
		return true
	}

	// Check if it's a single uppercase letter (A-Z)
	if len(name) == 1 && name[0] >= 'A' && name[0] <= 'Z' {
		return true
	}

	return false
}

// reportOutOfScopeTypes handles reporting and errors for types that are referenced but not in scope
func (g *Generator) reportOutOfScopeTypes() error {
	if len(g.OutOfScopeTypes) == 0 {
		return nil
	}

	action := g.Config.AutoGenerate.OutOfScopeTypes

	// Build a sorted list of out-of-scope types for consistent output
	typeNames := make([]string, 0, len(g.OutOfScopeTypes))
	for typeName := range g.OutOfScopeTypes {
		typeNames = append(typeNames, typeName)
	}
	sort.Strings(typeNames)

	// Build the message
	var msg strings.Builder
	msg.WriteString("\nOut-of-scope type references found:\n")
	msg.WriteString("=====================================\n")

	for _, typeName := range typeNames {
		refs := g.OutOfScopeTypes[typeName]
		// Sort by parent GQL name + field name for consistent output
		sort.Slice(refs, func(i, j int) bool {
			if refs[i].ParentGQLName != refs[j].ParentGQLName {
				return refs[i].ParentGQLName < refs[j].ParentGQLName
			}
			return refs[i].FieldName < refs[j].FieldName
		})

		msg.WriteString(fmt.Sprintf("\nType '%s' (not found in scanned packages) is referenced by:\n", typeName))
		for _, ref := range refs {
			// Look up the parent type in the registry to get full Go type path
			var parentGoTypeFull string
			for _, item := range g.GeneratedItems {
				if item.GQLName == ref.ParentGQLName {
					parentGoTypeFull = item.GoType
					break
				}
			}
			if parentGoTypeFull == "" {
				// Fallback if not found in registry
				parentGoTypeFull = ref.ParentGoType
			}

			msg.WriteString(fmt.Sprintf("  - %s.%s (GraphQL field)\n", ref.ParentGQLName, ref.FieldName))
			msg.WriteString(fmt.Sprintf("    Go: %s.%s (type: %s)\n", parentGoTypeFull, ref.GoFieldName, ref.GoFieldType))
		}
	}

	msg.WriteString("\nTo resolve this, you can:\n")
	msg.WriteString("  1. Add the package containing these types to your 'packages' configuration\n")
	msg.WriteString("  2. Map the fields to known types using custom type tags: gql:\"fieldName,type:KnownType\"\n")
	msg.WriteString("  3. Change 'out_of_scope_types' setting in config:\n")

	// Show current setting with indicator
	if action == OutOfScopeWarn {
		msg.WriteString("     - warn: Log warnings but continue (current)\n")
	} else {
		msg.WriteString("     - warn: Log warnings but continue\n")
	}
	if action == OutOfScopeFail {
		msg.WriteString("     - fail: Stop generation with error (current)\n")
	} else {
		msg.WriteString("     - fail: Stop generation with error\n")
	}
	if action == OutOfScopeIgnore {
		msg.WriteString("     - ignore: Allow undefined type references (current)\n")
	} else {
		msg.WriteString("     - ignore: Allow undefined type references\n")
	}
	if action == OutOfScopeExclude {
		msg.WriteString("     - exclude: Automatically exclude these fields from schema (current)\n")
	} else {
		msg.WriteString("     - exclude: Automatically exclude these fields from schema\n")
	}
	msg.WriteString("\n")

	switch action {
	case OutOfScopeFail:
		return fmt.Errorf("%s", msg.String())
	case OutOfScopeWarn:
		fmt.Fprintf(os.Stderr, "%s", msg.String())
	case OutOfScopeIgnore:
		// Do nothing - types are allowed even if undefined
	case OutOfScopeExclude:
		// Fields were already excluded during generation
		fmt.Fprintf(os.Stderr, "\nNote: %d field(s) were automatically excluded due to out-of-scope type references.\n", g.countExcludedFields())
		fmt.Fprintf(os.Stderr, "Set 'out_of_scope_types: ignore' if you want to include them anyway.\n\n")
	}

	return nil
}

// countExcludedFields counts the total number of fields that reference out-of-scope types
func (g *Generator) countExcludedFields() int {
	count := 0
	for _, refs := range g.OutOfScopeTypes {
		count += len(refs)
	}
	return count
}

// generateEnum generates a GraphQL enum definition from an EnumType
func (g *Generator) generateEnum(enumType *EnumType, ctx *GenerationContext) string {
	buf := strings.Builder{}

	// Add description if present
	if enumType.Description != "" {
		buf.WriteString(fmt.Sprintf("\"\"\"\n%s\n\"\"\"\n", enumType.Description))
	}

	buf.WriteString(fmt.Sprintf("enum %s", enumType.Name))

	// Add @goModel directive if gqlgen directives are enabled
	g.writeGoModelDirective(&buf, enumType.GoTypeName, false)

	buf.WriteString(" {\n")

	// Generate enum values
	for _, value := range enumType.Values {
		// Add description if present
		if value.Description != "" {
			buf.WriteString(fmt.Sprintf("  \"\"\"\n  %s\n  \"\"\"\n", value.Description))
		}

		// Add the enum value
		buf.WriteString(fmt.Sprintf("  %s", value.GraphQLName))

		// Add @goEnum directive if gqlgen directives are enabled
		if g.Config.UseGqlGenDirectives {
			// Use the package path where the const value is defined, not where the type is defined
			var valuePkgPath string
			if value.PackagePath != "" {
				// Use the stored package info for this specific const value
				valuePkgPath = g.P.GetPackageImportPathFromFile(value.PackagePath, value.PackageName, g.Config.ModelPath)
			} else {
				// Fallback to using the enum type's package (for backwards compatibility)
				valuePkgPath = g.P.GetPackageImportPath(enumType.GoTypeName, g.Config.ModelPath)
			}
			g.writeGoEnumDirective(&buf, valuePkgPath, value.GoName)
		}

		// Add deprecated directive if present
		g.writeDeprecatedDirective(&buf, value.Deprecated != "", value.Deprecated)

		buf.WriteString("\n")
	}

	buf.WriteString("}\n")

	// Register the generated enum
	g.registerGeneratedItem(GQLSchemaItem{
		OutputFile:    ctx.OutputFile,
		GoSourceFile:  g.P.EnumSourceFiles[enumType.GoTypeName],
		GoType:        enumType.GoTypeName,
		GoTypeName:    enumType.GoTypeName,
		GQLName:       enumType.Name,
		GQLKind:       "enum",
		Strategy:      ctx.Strategy,
		AutoGenerated: false, // Enums are not auto-generated
		Namespace:     ctx.Namespace,
	})

	return buf.String()
}
