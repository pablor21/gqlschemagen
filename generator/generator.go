// Package generator provides automatic GraphQL schema generation from Go structs.
//
// This package scans Go source code for struct definitions and generates GraphQL
// type definitions, input types, and schema files based on struct tags and special
// directives. It supports field name transformations, custom type mappings, and
// automatic input generation for mutations.
//
// # Features
//
//   - Automatic GraphQL type generation from Go structs
//   - Field name transformations (camelCase, snake_case, PascalCase)
//   - Support for gql tags and directives (@gqlgen, @gqlField, etc.)
//   - Automatic input type generation from structs
//   - Custom prefix/suffix stripping from type names
//   - Support for embedded structs and referenced types
//   - Configurable output strategies (single file or per-struct)
//
// # Basic Usage
//
//	parser := generator.NewParser()
//	err := parser.ParsePackages([]string{"./models"})
//	if err != nil {
//		panic(err)
//	}
//
//	config := generator.NewConfig()
//	config.Output = "schema.graphqls"
//
//	gen := generator.NewGenerator(parser, config)
//	err = gen.Run()
//	if err != nil {
//		panic(err)
//	}
//
// For detailed documentation and examples, see:
// https://github.com/pablor21/gqlschemagen
package generator

import (
	"fmt"
	"go/ast"
	"log/slog"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type Generator struct {
	P      *Parser
	Config *Config

	// AutoGeneratedTypes tracks types that should be auto-generated as GraphQL types
	// Key: type name, Value: true if should generate as type
	AutoGeneratedTypes map[string]bool

	// AutoGeneratedInputs tracks types that should be auto-generated as GraphQL inputs
	// Key: type name, Value: true if should generate as input
	AutoGeneratedInputs map[string]bool

	// OutOfScopeTypes tracks type references that are out of scope
	// Key: type name, Value: slice of field references with detailed info
	OutOfScopeTypes map[string][]OutOfScopeReference

	// GeneratedItems tracks all generated GraphQL schema items
	GeneratedItems []GQLSchemaItem
}

// OutOfScopeReference tracks a reference to an out-of-scope type
type OutOfScopeReference struct {
	ParentGoType   string // Go type of the parent struct (e.g., "Company")
	ParentGQLName  string // GraphQL name of the parent (e.g., "Company" or "CreateCompanyInput")
	GoFieldName    string // Go field name (e.g., "Test")
	FieldName      string // GraphQL field name (e.g., "test")
	GoFieldType    string // Go field type (e.g., "outofscope.AnotherOutOfScope")
	ReferencedType string // Referenced GraphQL type name (e.g., "AnotherOutOfScope")
}

// GQLSchemaItem represents a generated GraphQL schema item
type GQLSchemaItem struct {
	// OutputFile is the path to the generated schema file
	OutputFile string
	// GoSourceFile is the absolute path to the Go source file
	GoSourceFile string
	// GoType is the fully qualified Go type name (e.g., "github.com/user/pkg/models.User")
	GoType string
	// GoTypeName is the simple Go type name (e.g., "User")
	GoTypeName string
	// GQLName is the GraphQL type/input/enum name
	GQLName string
	// GQLKind is the kind of GraphQL schema item (type, input, enum)
	GQLKind string
	// Strategy is the generation strategy used (single, multiple, package, namespace)
	Strategy string
	// AutoGenerated indicates if this was auto-generated
	AutoGenerated bool
	// Namespace is the namespace if applicable
	Namespace string
}

// GenerationContext holds context for generating a specific GraphQL item
type GenerationContext struct {
	OutputFile string
	Strategy   string
	Namespace  string
}

func NewGenerator(p *Parser, config *Config) *Generator {
	if config == nil {
		config = NewConfig()
	}
	config.Normalize()
	return &Generator{
		P:                   p,
		Config:              config,
		AutoGeneratedTypes:  make(map[string]bool),
		AutoGeneratedInputs: make(map[string]bool),
		OutOfScopeTypes:     make(map[string][]OutOfScopeReference),
		GeneratedItems:      []GQLSchemaItem{},
	}
}

func (g *Generator) Run() error {
	// Build dependency graph and mark types for auto-generation
	if g.Config.AutoGenerate.Enabled {
		depGraph := g.BuildDependencyGraph()
		depGraph.MarkTypesForGeneration(g.Config)

		// Update parser's TypeNames to include auto-generated types
		g.applyAutoGeneration(depGraph)
	}

	// Check if we have any namespaces defined
	hasNamespaces := len(g.P.TypeNamespaces) > 0 || len(g.P.EnumNamespaces) > 0

	// Ensure output directory exists
	outputDir := g.Config.Output
	if g.Config.GenStrategy == GenStrategySingle && !hasNamespaces {
		// For single strategy without namespaces, check if Output is a file path or directory
		// If it ends with an extension, it's a file path - extract the directory
		if strings.HasSuffix(g.Config.Output, ".graphqls") || strings.HasSuffix(g.Config.Output, ".graphql") || strings.HasSuffix(g.Config.Output, ".gql") {
			outputDir = filepath.Dir(g.Config.Output)
		} else {
			outputDir = g.Config.Output
		}
	} else if g.Config.GenStrategy == GenStrategySingle && hasNamespaces {
		// When using namespaces with single strategy, output path should be treated as directory
		outputDir = g.Config.Output
	}
	if err := EnsureDir(outputDir); err != nil {
		return err
	}

	// Build topological order (AFTER auto-generation adds types to TypeNames)
	orders := g.buildDependencyOrder() // If namespaces are defined AND we're using package strategy, merge both approaches
	// If namespaces are defined with single/multiple strategy, use namespace generation
	// Otherwise, use the configured strategy
	var fileContents map[string]string
	var err error
	if hasNamespaces && g.Config.GenStrategy == GenStrategyPackage {
		fileContents, err = g.generateByNamespaceAndPackage(orders)
	} else if hasNamespaces {
		fileContents, err = g.generateByNamespace(orders)
	} else {
		// Generate based on strategy
		switch g.Config.GenStrategy {
		case GenStrategySingle:
			fileContents, err = g.generateSingleFile(orders)
		case GenStrategyPackage:
			fileContents, err = g.generatePackageFiles(orders)
		default: // GenStrategyMultiple
			fileContents, err = g.generateMultipleFiles(orders)
		}
	}

	if err != nil {
		return err
	}

	// Report out-of-scope types if any were found (BEFORE writing files)
	if len(g.OutOfScopeTypes) > 0 {
		outOfScopeErr := g.reportOutOfScopeTypes()
		if outOfScopeErr != nil {
			return outOfScopeErr
		}
	}

	// All validations passed - now write the files
	for outFile, content := range fileContents {
		if len(content) > 0 {
			// Ensure directory exists
			if err := EnsureDir(filepath.Dir(outFile)); err != nil {
				return err
			}
			if err := WriteFile(outFile, content, g.Config); err != nil {
				return err
			}
		}
	}

	// Log generation summary
	g.logGenerationSummary()

	return nil
}

// registerGeneratedItem records a generated GraphQL schema item
func (g *Generator) registerGeneratedItem(item GQLSchemaItem) {
	g.GeneratedItems = append(g.GeneratedItems, item)
}

// logGenerationSummary logs a summary of all generated items
func (g *Generator) logGenerationSummary() {
	if len(g.GeneratedItems) == 0 {
		return
	}

	slog.Info("Generation summary", "total_items", len(g.GeneratedItems))

	// Group by kind
	byKind := make(map[string]int)
	byStrategy := make(map[string]int)
	autoGenCount := 0

	for _, item := range g.GeneratedItems {
		byKind[item.GQLKind]++
		byStrategy[item.Strategy]++
		if item.AutoGenerated {
			autoGenCount++
		}
	}

	slog.Debug("Generation details",
		"types", byKind["type"],
		"inputs", byKind["input"],
		"enums", byKind["enum"],
		"auto_generated", autoGenCount,
	)

	// Log detailed items in debug mode
	for _, item := range g.GeneratedItems {
		slog.Debug("Generated item",
			"kind", item.GQLKind,
			"gql_name", item.GQLName,
			"go_type", item.GoTypeName,
			"file", item.OutputFile,
			"auto_gen", item.AutoGenerated,
			"namespace", item.Namespace,
		)
	}
}

func (g *Generator) buildDependencyOrder() []string {
	names := make([]string, 0, len(g.P.TypeNames))
	// for _, n := range g.P.TypeNames {
	// 	names = append(names, n)
	// }
	names = append(names, g.P.TypeNames...)
	sort.Strings(names)

	// Topological sort
	orders := []string{}
	visited := map[string]bool{}
	var dfs func(string)
	dfs = func(n string) {
		if visited[n] {
			return
		}
		visited[n] = true
		st := g.P.Structs[n]
		if st == nil {
			return
		}
		for _, f := range st.Fields.List {
			ft := FieldTypeName(f.Type)
			if _, ok := g.P.Structs[ft]; ok {
				dfs(ft)
			}
		}
		orders = append(orders, n)
	}
	for _, n := range names {
		dfs(n)
	}
	return orders
}

// generateTypeContent generates GraphQL type definitions for a given struct with tracking context
// This is a shared helper used by all generation strategies
func (g *Generator) generateTypeContent(typeName string, typeSpec *ast.TypeSpec, d StructDirectives, ctx *GenerationContext) string {
	buf := strings.Builder{}

	// Generate all types from @gqlType directives
	if d.HasTypeDirective {
		slog.Debug("Generating type from directive", "type", typeName, "count", len(d.Types))
		for _, typeDef := range d.Types {
			typeContent := g.generateTypeFromDef(typeSpec, g.P.Structs[typeName], d, typeDef, ctx)
			if typeContent != "" {
				buf.WriteString(typeContent)
			}
		}
	} else if g.AutoGeneratedTypes[typeName] {
		// Auto-generated type without explicit @gqlType annotation
		slog.Debug("Auto-generating type", "type", typeName)
		defaultTypeDef := TypeDefinition{
			Name:        typeName,
			Description: "",
		}
		typeContent := g.generateTypeFromDef(typeSpec, g.P.Structs[typeName], d, defaultTypeDef, ctx)
		if typeContent != "" {
			buf.WriteString(typeContent)
		}
	}

	return buf.String()
}

// generateInputContent generates GraphQL input definitions for a given struct with tracking context
// This is a shared helper used by all generation strategies
func (g *Generator) generateInputContent(typeName string, typeSpec *ast.TypeSpec, d StructDirectives, ctx *GenerationContext) string {
	buf := strings.Builder{}

	// Generate all inputs from @gqlInput directives
	if d.HasInputDirective {
		slog.Debug("Generating input from directive", "type", typeName, "count", len(d.Inputs))
		for _, inputDef := range d.Inputs {
			inputContent := g.generateInputFromDef(typeSpec, g.P.Structs[typeName], d, inputDef, ctx)
			if inputContent != "" {
				buf.WriteString(inputContent)
			}
		}
	} else if g.AutoGeneratedInputs[typeName] {
		// Auto-generated input without explicit @gqlInput annotation
		slog.Debug("Auto-generating input", "type", typeName)
		defaultInputDef := InputDefinition{
			Name:        typeName + "Input",
			Description: "",
		}
		inputContent := g.generateInputFromDef(typeSpec, g.P.Structs[typeName], d, defaultInputDef, ctx)
		if inputContent != "" {
			buf.WriteString(inputContent)
		}
	}

	return buf.String()
}

// generateByNamespace generates schema files organized by namespace
func (g *Generator) generateByNamespace(orders []string) (map[string]string, error) {
	slog.Info("Generating schema using namespace strategy")
	// Group types, inputs, and enums by namespace
	type namespaceItems struct {
		types  map[string][]TypeDefinition  // typeName -> type definitions
		inputs map[string][]InputDefinition // typeName -> input definitions
		enums  []string                     // enum names
	}

	namespaces := make(map[string]*namespaceItems)

	// Helper to get or create namespace group
	getNamespace := func(ns string) *namespaceItems {
		if ns == "" {
			ns = "_default"
		}
		if namespaces[ns] == nil {
			namespaces[ns] = &namespaceItems{
				types:  make(map[string][]TypeDefinition),
				inputs: make(map[string][]InputDefinition),
				enums:  []string{},
			}
		}
		return namespaces[ns]
	}

	// Group types and inputs by namespace (file-level or directive-level)
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil || g.P.TypeToDecl[typeName] == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Get file-level namespace for this type
		fileNamespace := g.P.TypeNamespaces[typeName]

		// Group types by their namespace (directive-level overrides file-level)
		if d.HasTypeDirective {
			for _, typeDef := range d.Types {
				ns := typeDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}
				nsItems := getNamespace(ns)
				nsItems.types[typeName] = append(nsItems.types[typeName], typeDef)
			}
		} else if g.AutoGeneratedTypes[typeName] {
			// Auto-generated type without explicit @gqlType annotation
			defaultTypeDef := TypeDefinition{
				Name:        typeName,
				Description: "",
				Namespace:   fileNamespace,
			}
			nsItems := getNamespace(fileNamespace)
			nsItems.types[typeName] = append(nsItems.types[typeName], defaultTypeDef)
		}

		// Group inputs by their namespace (directive-level overrides file-level)
		if d.HasInputDirective {
			for _, inputDef := range d.Inputs {
				ns := inputDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}
				nsItems := getNamespace(ns)
				nsItems.inputs[typeName] = append(nsItems.inputs[typeName], inputDef)
			}
		} else if g.AutoGeneratedInputs[typeName] {
			// Auto-generated input without explicit @gqlInput annotation
			defaultInputDef := InputDefinition{
				Name:        typeName + "Input",
				Description: "",
				Namespace:   fileNamespace,
			}
			nsItems := getNamespace(fileNamespace)
			nsItems.inputs[typeName] = append(nsItems.inputs[typeName], defaultInputDef)
		}
	}

	// Group enums by namespace
	for _, enumName := range g.P.EnumNames {
		ns := g.P.EnumNamespaces[enumName]
		nsItems := getNamespace(ns)
		nsItems.enums = append(nsItems.enums, enumName)
	}

	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Generate content for each namespace
	for namespace, items := range namespaces {
		var outFile string

		if namespace == "_default" {
			// Types without namespace go to default location
			outFile = filepath.Join(g.Config.Output, g.Config.OutputFileName)
		} else {
			// Convert namespace to file path using configured separator
			// e.g., "user/auth" with separator "/" becomes "user/auth.graphqls"
			namespacePath := namespace
			if g.Config.NamespaceSeparator != "/" {
				namespacePath = strings.ReplaceAll(namespace, g.Config.NamespaceSeparator, string(filepath.Separator))
			}
			outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
		}

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating buffer for namespace file", "file", outFile, "namespace", namespace)
		}

		// Create generation context for this namespace file
		ctx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "namespace",
			Namespace:  namespace,
		}

		// Generate enums for this namespace
		slog.Debug("Generating enums for namespace", "namespace", namespace, "count", len(items.enums))
		for _, enumName := range items.enums {
			enumType := g.P.EnumTypes[enumName]
			if enumType == nil {
				continue
			}
			enumContent := g.generateEnum(enumType, ctx)
			if enumContent != "" {
				buf.WriteString(enumContent)
				buf.WriteString("\n")
			}
		}

		// Generate types and inputs for this namespace
		slog.Debug("Generating types for namespace", "namespace", namespace, "count", len(items.types))

		// Context already created above

		// Sort type names for deterministic output
		typeNames := make([]string, 0, len(items.types))
		for typeName := range items.types {
			typeNames = append(typeNames, typeName)
		}
		sort.Strings(typeNames)

		for _, typeName := range typeNames {
			typeDefs := items.types[typeName]
			typeSpec := g.P.StructTypes[typeName]
			structType := g.P.Structs[typeName]
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, typeDef := range typeDefs {
				typeContent := g.generateTypeFromDef(typeSpec, structType, d, typeDef, ctx)
				if typeContent != "" {
					buf.WriteString(typeContent)
				}
			}
		}

		// Generate inputs for this namespace
		slog.Debug("Generating inputs for namespace", "namespace", namespace, "count", len(items.inputs))
		for typeName, inputDefs := range items.inputs {
			typeSpec := g.P.StructTypes[typeName]
			structType := g.P.Structs[typeName]
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, inputDef := range inputDefs {
				inputContent := g.generateInputFromDef(typeSpec, structType, d, inputDef, ctx)
				if inputContent != "" {
					buf.WriteString(inputContent)
				}
			}
		}
	}

	// Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

// generateByNamespaceAndPackage combines namespace and package strategies
// Types with namespaces use namespace, types without use package directory
func (g *Generator) generateByNamespaceAndPackage(orders []string) (map[string]string, error) {
	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Helper to get or create buffer for a file
	getBuffer := func(filePath string) *strings.Builder {
		buf, exists := fileContents[filePath]
		if !exists {
			buf = &strings.Builder{}
			fileContents[filePath] = buf
		}
		return buf
	}

	// Process enums
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}

		var outFile string
		ns := g.P.EnumNamespaces[enumName]

		if ns != "" {
			// Use namespace
			namespacePath := ns
			if g.Config.NamespaceSeparator != "/" {
				namespacePath = strings.ReplaceAll(ns, g.Config.NamespaceSeparator, string(filepath.Separator))
			}
			outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
		} else {
			// Use package directory
			filePath := g.P.PackagePaths[enumName]
			pkgDir := filepath.Dir(filePath)
			pkgName := filepath.Base(pkgDir)
			outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
		}

		if g.Config.SkipExisting && FileExists(outFile) {
			continue
		}

		buf := getBuffer(outFile)
		// Create context for this namespace/package file
		enumCtx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "namespace+package",
			Namespace:  ns,
		}
		enumContent := g.generateEnum(enumType, enumCtx)
		if enumContent != "" {
			buf.WriteString(enumContent)
			buf.WriteString("\n")
		}
	}

	// Process types and inputs
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Skip if no directives present
		if !d.HasTypeDirective && !d.HasInputDirective {
			continue
		}

		// Get file-level namespace for this type
		fileNamespace := g.P.TypeNamespaces[typeName]

		// Process types
		if d.HasTypeDirective {
			for _, typeDef := range d.Types {
				var outFile string
				ns := typeDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}

				if ns != "" {
					// Use namespace
					namespacePath := ns
					if g.Config.NamespaceSeparator != "/" {
						namespacePath = strings.ReplaceAll(ns, g.Config.NamespaceSeparator, string(filepath.Separator))
					}
					outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
				} else {
					// Use package directory
					filePath := g.P.PackagePaths[typeName]
					pkgDir := filepath.Dir(filePath)
					pkgName := filepath.Base(pkgDir)
					outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
				}

				if g.Config.SkipExisting && FileExists(outFile) {
					continue
				}

				buf := getBuffer(outFile)
				// Create context for this namespace+package file
				ctx := &GenerationContext{
					OutputFile: outFile,
					Strategy:   "namespace+package",
					Namespace:  ns,
				}
				typeContent := g.generateTypeFromDef(typeSpec, g.P.Structs[typeName], d, typeDef, ctx)
				if typeContent != "" {
					buf.WriteString(typeContent)
				}
			}
		}

		// Process inputs
		if d.HasInputDirective {
			for _, inputDef := range d.Inputs {
				var outFile string
				ns := inputDef.Namespace
				if ns == "" {
					ns = fileNamespace
				}

				if ns != "" {
					// Use namespace
					namespacePath := ns
					if g.Config.NamespaceSeparator != "/" {
						namespacePath = strings.ReplaceAll(ns, g.Config.NamespaceSeparator, string(filepath.Separator))
					}
					outFile = filepath.Join(g.Config.Output, namespacePath+g.Config.OutputFileExtension)
				} else {
					// Use package directory
					filePath := g.P.PackagePaths[typeName]
					pkgDir := filepath.Dir(filePath)
					pkgName := filepath.Base(pkgDir)
					outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
				}

				if g.Config.SkipExisting && FileExists(outFile) {
					continue
				}

				buf := getBuffer(outFile)
				// Create context for this namespace+package file
				ctx := &GenerationContext{
					OutputFile: outFile,
					Strategy:   "namespace+package",
					Namespace:  ns,
				}
				inputContent := g.generateInputFromDef(typeSpec, g.P.Structs[typeName], d, inputDef, ctx)
				if inputContent != "" {
					buf.WriteString(inputContent)
				}
			}
		}
	}

	// Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

func (g *Generator) generateSingleFile(orders []string) (map[string]string, error) {
	slog.Info("Generating single schema file")

	// Determine output file path
	// If Output ends with an extension (old style), use it directly
	// If Output is a directory (new style), join with OutputFileName
	var outFile string
	if strings.HasSuffix(g.Config.Output, ".graphqls") || strings.HasSuffix(g.Config.Output, ".graphql") || strings.HasSuffix(g.Config.Output, ".gql") {
		// Old style: Output is the full file path
		outFile = g.Config.Output
	} else {
		// New style: Output is directory, use OutputFileName
		outFile = filepath.Join(g.Config.Output, g.Config.OutputFileName)
	}

	if g.Config.SkipExisting && FileExists(outFile) {
		slog.Info("Skipping existing file", "file", outFile)
		fmt.Println("skip", outFile)
		return map[string]string{}, nil
	}

	slog.Debug("Output file", "path", outFile)
	buf := strings.Builder{}
	// Add code generation notice
	//buf.WriteString("# Code generated by https://github.com/pablor21/gqlschemagen, DO NOT EDIT.\n\n")

	// Create generation context for single file strategy
	ctx := &GenerationContext{
		OutputFile: outFile,
		Strategy:   "single",
		Namespace:  "",
	}

	// Generate enums first
	slog.Debug("Generating enums", "count", len(g.P.EnumNames))
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}
		enumContent := g.generateEnum(enumType, ctx)
		if enumContent != "" {
			buf.WriteString(enumContent)
			buf.WriteString("\n")
		}
	}

	slog.Debug("Generating types and inputs", "count", len(orders))
	// Context already created above
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil || g.P.TypeToDecl[typeName] == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Use shared helper functions to generate types and inputs with context
		buf.WriteString(g.generateTypeContent(typeName, typeSpec, d, ctx))
		buf.WriteString(g.generateInputContent(typeName, typeSpec, d, ctx))
	}

	return map[string]string{outFile: buf.String()}, nil
}

func (g *Generator) generatePackageFiles(orders []string) (map[string]string, error) {
	slog.Info("Generating schema files by package")

	// Group types, inputs, and enums by their Go package path
	type packageItems struct {
		types  map[string][]TypeDefinition  // typeName -> type definitions
		inputs map[string][]InputDefinition // typeName -> input definitions
		enums  []string                     // enum names
	}

	packages := make(map[string]*packageItems)

	// Helper to get or create package group
	getPackage := func(pkgPath string) *packageItems {
		if pkgPath == "" {
			pkgPath = "_default"
		}
		if packages[pkgPath] == nil {
			packages[pkgPath] = &packageItems{
				types:  make(map[string][]TypeDefinition),
				inputs: make(map[string][]InputDefinition),
				enums:  []string{},
			}
		}
		return packages[pkgPath]
	}

	// Group enums by package
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}
		// Get package directory from file path in PackagePaths
		filePath := g.P.PackagePaths[enumName]
		pkgDir := filepath.Dir(filePath)
		pkg := getPackage(pkgDir)
		pkg.enums = append(pkg.enums, enumName)
	}

	// Group types and inputs by package
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Get package directory from file path in PackagePaths
		filePath := g.P.PackagePaths[typeName]
		pkgDir := filepath.Dir(filePath)
		pkg := getPackage(pkgDir)

		// Add types
		if d.HasTypeDirective {
			pkg.types[typeName] = append(pkg.types[typeName], d.Types...)
		} else if g.AutoGeneratedTypes[typeName] {
			// Auto-generated type without explicit @gqlType annotation
			defaultTypeDef := TypeDefinition{
				Name:        typeName,
				Description: "",
			}
			pkg.types[typeName] = append(pkg.types[typeName], defaultTypeDef)
		}

		// Add inputs
		if d.HasInputDirective {
			pkg.inputs[typeName] = append(pkg.inputs[typeName], d.Inputs...)
		} else if g.AutoGeneratedInputs[typeName] {
			// Auto-generated input without explicit @gqlInput annotation
			defaultInputDef := InputDefinition{
				Name:        typeName + "Input",
				Description: "",
			}
			pkg.inputs[typeName] = append(pkg.inputs[typeName], defaultInputDef)
		}
	}

	// Sort package paths for deterministic output
	pkgPaths := make([]string, 0, len(packages))
	for pkgPath := range packages {
		pkgPaths = append(pkgPaths, pkgPath)
	}
	sort.Strings(pkgPaths)

	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Generate content for each package
	for _, pkgPath := range pkgPaths {
		items := packages[pkgPath]

		// Determine output file name from package path
		var outFile string
		if pkgPath == "_default" {
			// Types without package go to default location
			outFile = filepath.Join(g.Config.Output, g.Config.OutputFileName)
		} else {
			// Use the last segment of the package path as the file name
			// e.g., "/path/to/models" -> "models.graphqls"
			pkgName := filepath.Base(pkgPath)
			// Remove .go extension if present
			pkgName = strings.TrimSuffix(pkgName, ".go")
			outFile = filepath.Join(g.Config.Output, pkgName+g.Config.OutputFileExtension)
		}

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating buffer for package file", "file", outFile, "package", pkgPath)
		}

		// Create generation context for this package file
		ctx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "package",
			Namespace:  "",
		}

		// Generate enums for this package
		slog.Debug("Generating enums for package", "package", pkgPath, "count", len(items.enums))
		for _, enumName := range items.enums {
			enumType := g.P.EnumTypes[enumName]
			if enumType == nil {
				continue
			}
			enumContent := g.generateEnum(enumType, ctx)
			if enumContent != "" {
				buf.WriteString(enumContent)
				buf.WriteString("\n")
			}
		}

		// Generate types and inputs for this package
		slog.Debug("Generating types for package", "package", pkgPath, "count", len(items.types))

		// Context already created above

		// Sort type names for deterministic output
		typeNames := make([]string, 0, len(items.types))
		for typeName := range items.types {
			typeNames = append(typeNames, typeName)
		}
		sort.Strings(typeNames)

		for _, typeName := range typeNames {
			typeDefs := items.types[typeName]
			typeSpec := g.P.StructTypes[typeName]
			structType := g.P.Structs[typeName]
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, typeDef := range typeDefs {
				typeContent := g.generateTypeFromDef(typeSpec, structType, d, typeDef, ctx)
				if typeContent != "" {
					buf.WriteString(typeContent)
				}
			}
		}

		// Generate inputs for this package
		slog.Debug("Generating inputs for package", "package", pkgPath, "count", len(items.inputs))
		for typeName, inputDefs := range items.inputs {
			typeSpec := g.P.StructTypes[typeName]
			structType := g.P.Structs[typeName]
			d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])

			for _, inputDef := range inputDefs {
				inputContent := g.generateInputFromDef(typeSpec, structType, d, inputDef, ctx)
				if inputContent != "" {
					buf.WriteString(inputContent)
				}
			}
		}
	}

	// Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

func (g *Generator) generateMultipleFiles(orders []string) (map[string]string, error) {
	slog.Info("Generating multiple schema files (one per type)")

	// Collect all content in memory first (map of file path -> content)
	fileContents := make(map[string]*strings.Builder)

	// Generate enums first
	slog.Debug("Generating enum files", "count", len(g.P.EnumNames))
	for _, enumName := range g.P.EnumNames {
		enumType := g.P.EnumTypes[enumName]
		if enumType == nil {
			continue
		}

		fileName := strings.ToLower(enumName) + g.Config.OutputFileExtension
		outFile := filepath.Join(g.Config.Output, fileName)

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating file for enum", "file", outFile, "enum", enumName)
		}

		// Create generation context for this enum file
		enumCtx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "multiple",
			Namespace:  "",
		}

		enumContent := g.generateEnum(enumType, enumCtx)
		if enumContent != "" {
			buf.WriteString(enumContent)
		}
	}

	// Generate types and inputs
	slog.Debug("Generating type and input files", "count", len(orders))
	for _, typeName := range orders {
		typeSpec := g.P.StructTypes[typeName]
		if typeSpec == nil {
			continue
		}

		d := ParseDirectives(typeSpec, g.P.TypeToDecl[typeName])
		if d.SkipType {
			continue
		}

		// Skip if no directives present and not auto-generated
		if !d.HasTypeDirective && !d.HasInputDirective && !g.AutoGeneratedTypes[typeName] && !g.AutoGeneratedInputs[typeName] {
			continue
		}

		// Generate filename
		fileName := g.resolveFileName(d, typeSpec.Name.Name)
		outFile := filepath.Join(g.Config.Output, fileName)

		if g.Config.SkipExisting && FileExists(outFile) {
			slog.Info("Skipping existing file", "file", outFile)
			continue
		}

		// Get or create buffer for this file
		buf, exists := fileContents[outFile]
		if !exists {
			buf = &strings.Builder{}
			fileContents[outFile] = buf
			slog.Debug("Creating file for type", "file", outFile, "type", typeName)
		}

		// Create generation context for this file
		ctx := &GenerationContext{
			OutputFile: outFile,
			Strategy:   "multiple",
			Namespace:  "",
		}

		// Use shared helper functions to generate types and inputs with context
		buf.WriteString(g.generateTypeContent(typeName, typeSpec, d, ctx))
		buf.WriteString(g.generateInputContent(typeName, typeSpec, d, ctx))
	}

	// Convert buffers to strings and return
	result := make(map[string]string)
	for outFile, buf := range fileContents {
		if buf.Len() > 0 {
			result[outFile] = buf.String()
		}
	}

	return result, nil
}

func (g *Generator) resolveFileName(d StructDirectives, typeName string) string {
	pattern := g.Config.SchemaFileName
	if pattern == "" {
		pattern = "{model_name}.graphqls"
	}

	modelName := strings.ToLower(d.GQLName)
	pattern = strings.ReplaceAll(pattern, "{model_name}", modelName)
	pattern = strings.ReplaceAll(pattern, "{type_name}", typeName)

	return pattern
}

// writeGoModelDirective writes the @goModel directive if enabled
func (g *Generator) writeGoModelDirective(buf *strings.Builder, goTypeName string, useDirective bool) {
	if g.Config.UseGqlGenDirectives || useDirective {
		pkgPath := g.P.GetPackageImportPath(goTypeName, g.Config.ModelPath)
		fmt.Fprintf(buf, " @goModel(model: \"%s.%s\")", pkgPath, goTypeName)
	}
}

// writeGoFieldDirective writes the @goField(forceResolver: true) directive if enabled
func (g *Generator) writeGoFieldDirective(buf *strings.Builder, forceResolver bool) {
	if g.Config.UseGqlGenDirectives && forceResolver {
		buf.WriteString(" @goField(forceResolver: true)")
	}
}

// writeDeprecatedDirective writes the @deprecated directive with optional reason
func (g *Generator) writeDeprecatedDirective(buf *strings.Builder, deprecated bool, reason string) {
	if !deprecated {
		return
	}
	if reason != "" {
		// Escape quotes in the reason
		escapedReason := strings.ReplaceAll(reason, `"`, `\"`)
		fmt.Fprintf(buf, ` @deprecated(reason: "%s")`, escapedReason)
	} else {
		buf.WriteString(" @deprecated")
	}
}

// writeGoEnumDirective writes the @goEnum directive if enabled
func (g *Generator) writeGoEnumDirective(buf *strings.Builder, valuePkgPath string, valueGoName string) {
	if g.Config.UseGqlGenDirectives {
		fmt.Fprintf(buf, " @goEnum(value: \"%s.%s\")", valuePkgPath, valueGoName)
	}
}

// generateTypeFromDef generates a GraphQL type from a specific TypeDefinition
// generateTypeFromDef generates a GraphQL type with generation context for tracking
func (g *Generator) generateTypeFromDef(typeSpec *ast.TypeSpec, st *ast.StructType, d StructDirectives, typeDef TypeDefinition, ctx *GenerationContext) string {
	typeName := typeSpec.Name.Name
	name := d.GQLName
	if typeDef.Name != "" {
		// Use custom type name from @gqlType annotation
		name = typeDef.Name
	} else {
		// Apply prefix/suffix stripping only when no custom name is specified
		name = StripPrefixSuffix(name, g.Config.StripPrefix, g.Config.StripSuffix)
		// Apply prefix/suffix addition
		if g.Config.AddTypePrefix != "" {
			name = g.Config.AddTypePrefix + name
		}
		if g.Config.AddTypeSuffix != "" {
			name = name + g.Config.AddTypeSuffix
		}
	}

	buf := strings.Builder{}

	// Add description if present
	if typeDef.Description != "" {
		buf.WriteString(fmt.Sprintf("\"\"\"%s\"\"\"\n", typeDef.Description))
	}

	// Type declaration
	buf.WriteString(fmt.Sprintf("type %s", name))

	// Add @goModel directive if enabled
	g.writeGoModelDirective(&buf, typeSpec.Name.Name, d.UseModelDirective)

	buf.WriteString(" {\n")

	// Generate fields from struct (use typeDef.IgnoreAll instead of d.TypeIgnoreAll)
	fields := g.generateFieldsForTypeNamed(st, d, typeDef.IgnoreAll, false, name)

	// Count applicable extra fields for this type
	applicableExtraFields := 0
	for _, ef := range d.TypeExtraFields {
		if shouldApplyExtraField(ef, name) {
			applicableExtraFields++
		}
	}

	if len(fields) == 0 && applicableExtraFields == 0 && !g.Config.IncludeEmptyTypes {
		return "" // Skip empty types
	}

	buf.WriteString(fields)

	// Add extra fields from @gqlTypeExtraField annotations
	for _, ef := range d.TypeExtraFields {
		// Check if this field applies to this type
		if !shouldApplyExtraField(ef, name) {
			continue
		}
		if ef.Description != "" {
			buf.WriteString(fmt.Sprintf("\t\"\"\"%s\"\"\"\n", ef.Description))
		}
		buf.WriteString(fmt.Sprintf("\t%s: %s", ef.Name, ef.Type))
		g.writeGoFieldDirective(&buf, true)
		buf.WriteString("\n")
	}

	buf.WriteString("}\n\n")

	// Register generated item
	pkgPath := g.P.GetPackageImportPath(typeName, g.Config.ModelPath)
	g.registerGeneratedItem(GQLSchemaItem{
		OutputFile:    ctx.OutputFile,
		GoSourceFile:  g.P.SourceFiles[typeName],
		GoType:        pkgPath + "." + typeName,
		GoTypeName:    typeName,
		GQLName:       name,
		GQLKind:       "type",
		Strategy:      ctx.Strategy,
		AutoGenerated: g.AutoGeneratedTypes[typeName],
		Namespace:     ctx.Namespace,
	})

	return buf.String()
}

// generateInputFromDef generates a GraphQL input from a specific InputDefinition
// generateInputFromDef generates a GraphQL input with generation context for tracking
func (g *Generator) generateInputFromDef(typeSpec *ast.TypeSpec, st *ast.StructType, d StructDirectives, inputDef InputDefinition, ctx *GenerationContext) string {
	typeName := typeSpec.Name.Name
	inputName := inputDef.Name
	if inputName == "" {
		// Apply prefix/suffix stripping before adding "Input" suffix
		baseName := StripPrefixSuffix(d.GQLName, g.Config.StripPrefix, g.Config.StripSuffix)

		// For auto-generated inputs, check if the type name already ends with "Input"
		// to avoid CreateUserInput -> CreateUserInputInput
		if !strings.HasSuffix(baseName, "Input") {
			inputName = baseName + "Input"
		} else {
			inputName = baseName
		}

		// Apply prefix/suffix addition
		if g.Config.AddInputPrefix != "" {
			inputName = g.Config.AddInputPrefix + inputName
		}
		if g.Config.AddInputSuffix != "" {
			inputName = inputName + g.Config.AddInputSuffix
		}
	}

	buf := strings.Builder{}

	// Add description if present
	if inputDef.Description != "" {
		buf.WriteString(fmt.Sprintf("\"\"\"%s\"\"\"\n", inputDef.Description))
	}

	// Input declaration
	buf.WriteString(fmt.Sprintf("input %s", inputName))

	// Add @goModel directive if enabled
	g.writeGoModelDirective(&buf, typeSpec.Name.Name, d.UseModelDirective)

	buf.WriteString(" {\n")

	// Generate fields from struct (use inputDef.IgnoreAll instead of d.InputIgnoreAll)
	fields := g.generateFieldsForTypeNamed(st, d, inputDef.IgnoreAll, true, inputName)

	// Count applicable extra fields for this input
	applicableExtraFields := 0
	for _, ef := range d.InputExtraFields {
		if shouldApplyExtraField(ef, inputName) {
			applicableExtraFields++
		}
	}

	if len(fields) == 0 && applicableExtraFields == 0 && !g.Config.IncludeEmptyTypes {
		return "" // Skip empty inputs
	}

	buf.WriteString(fields)

	// Add extra fields from @gqlInputExtraField annotations
	for _, ef := range d.InputExtraFields {
		// Check if this field applies to this input
		if !shouldApplyExtraField(ef, inputName) {
			continue
		}
		if ef.Description != "" {
			buf.WriteString(fmt.Sprintf("\t\"\"\"%s\"\"\"\n", ef.Description))
		}
		buf.WriteString(fmt.Sprintf("\t%s: %s\n", ef.Name, ef.Type))
	}

	buf.WriteString("}\n\n")

	// Register generated item
	pkgPath := g.P.GetPackageImportPath(typeName, g.Config.ModelPath)
	g.registerGeneratedItem(GQLSchemaItem{
		OutputFile:    ctx.OutputFile,
		GoSourceFile:  g.P.SourceFiles[typeName],
		GoType:        pkgPath + "." + typeName,
		GoTypeName:    typeName,
		GQLName:       inputName,
		GQLKind:       "input",
		Strategy:      ctx.Strategy,
		AutoGenerated: g.AutoGeneratedInputs[typeName],
		Namespace:     ctx.Namespace,
	})

	return buf.String()
}

// generateFieldsForType generates fields with specific ignoreAll setting
// func (g *Generator) generateFieldsForType(st *ast.StructType, d StructDirectives, typeIgnoreAll bool, forInput bool) string {
// 	return g.generateFieldsForTypeNamed(st, d, typeIgnoreAll, forInput, "")
// }

// generateFieldsForTypeNamed generates fields with specific ignoreAll setting and type/input name for filtering
func (g *Generator) generateFieldsForTypeNamed(st *ast.StructType, d StructDirectives, typeIgnoreAll bool, forInput bool, typeName string) string {
	buf := strings.Builder{}

	// Determine which ignoreAll flag to use
	ignoreAll := d.IgnoreAll || typeIgnoreAll

	for _, f := range st.Fields.List {
		// Handle embedded fields
		if f.Names == nil {
			// This is an embedded field - expand its fields
			embeddedFields := g.expandEmbeddedFieldNamed(f, d, ignoreAll, forInput, typeName)
			buf.WriteString(embeddedFields)
			continue
		}

		opt := ParseFieldOptions(f, g.Config)

		// Determine if field should be included using new type-specific logic
		include := shouldIncludeField(opt, ignoreAll, forInput, typeName)
		if !include {
			continue
		}

		// Resolve field name
		fieldName := opt.Name
		if fieldName == "" {
			fieldName = ResolveFieldName(f, g.Config)
		}

		// Resolve field type
		fieldType := opt.Type
		if fieldType == "" {
			if forInput {
				// For inputs, convert type references to input references
				fieldType = ExprToGraphQLTypeForInput(f.Type, g.Config.KnownScalars, g.P.EnumTypes)
			} else {
				fieldType = ExprToGraphQLType(f.Type)
			}
		}

		// Check if field type is out of scope (if no custom type was specified)
		if opt.Type == "" {
			baseTypeName := g.extractBaseTypeName(fieldType)
			if baseTypeName != "" && !g.isTypeInScope(baseTypeName) {
				// Get the Go field name and type from AST
				goFieldName := f.Names[0].Name
				goFieldType := ExprToGoType(f.Type)

				// Determine parent GQL name (could be type or input)
				parentGQLName := typeName
				if forInput {
					// For inputs, we need to find the actual input name being generated
					// typeName is the input name passed to generateFieldsForTypeNamed
					parentGQLName = typeName
				}

				ref := OutOfScopeReference{
					ParentGoType:   typeName,
					ParentGQLName:  parentGQLName,
					GoFieldName:    goFieldName,
					FieldName:      fieldName,
					GoFieldType:    goFieldType,
					ReferencedType: baseTypeName,
				}
				g.OutOfScopeTypes[baseTypeName] = append(g.OutOfScopeTypes[baseTypeName], ref) // Handle based on configuration
				switch g.Config.AutoGenerate.OutOfScopeTypes {
				case OutOfScopeExclude:
					// Skip this field - don't include in schema
					continue
				case OutOfScopeFail:
					// Include field but error will be reported at end
					// Don't continue - let field be added to schema
				case OutOfScopeIgnore:
					// Continue with the field as-is
				case OutOfScopeWarn:
					// Continue with the field, warning will be logged later
				}
			}
		}

		// Handle optional/required
		if opt.Optional {
			fieldType = strings.TrimSuffix(fieldType, "!")
		} else if opt.Required && !strings.HasSuffix(fieldType, "!") {
			fieldType = fieldType + "!"
		}

		// Add field with description if present
		if opt.Description != "" {
			buf.WriteString(fmt.Sprintf("    \"\"\"%s\"\"\"\n", opt.Description))
		}

		buf.WriteString(fmt.Sprintf("    %s: %s", fieldName, fieldType))

		// Add @goField directive if forceResolver is set
		g.writeGoFieldDirective(&buf, opt.ForceResolver)

		// Add @deprecated directive if field is deprecated
		g.writeDeprecatedDirective(&buf, opt.Deprecated, opt.DeprecatedReason)
		buf.WriteString("\n")
	}

	return buf.String()
}

// shouldApplyExtraField checks if an extra field should be applied to a given type/input name
// based on the 'on' filter. Returns true if:
// - On is empty (no filter specified, defaults to all)
// - On contains "*" (explicitly apply to all)
// - On contains the targetName
func shouldApplyExtraField(ef ExtraField, targetName string) bool {
	if len(ef.On) == 0 {
		return true
	}
	for _, name := range ef.On {
		if name == "*" || name == targetName {
			return true
		}
	}
	return false
}

// shouldIncludeField determines if a field should be included in a type/input
// based on the FieldOptions and context (forInput, typeName)
func shouldIncludeField(opt FieldOptions, ignoreAll bool, forInput bool, typeName string) bool {
	// Handle read-only (ro): include only in types, ignore in inputs
	if len(opt.ReadOnly) > 0 {
		if forInput {
			return false // Exclude from inputs
		}
		// Include in types only if typeName matches or is *
		return matchesTypeList(opt.ReadOnly, typeName)
	}

	// Handle write-only (wo): include only in inputs, ignore in types
	if len(opt.WriteOnly) > 0 {
		if !forInput {
			return false // Exclude from types
		}
		// Include in inputs only if typeName matches or is *
		return matchesTypeList(opt.WriteOnly, typeName)
	}

	// Handle read-write (rw): include in both types and inputs
	if len(opt.ReadWrite) > 0 {
		return matchesTypeList(opt.ReadWrite, typeName)
	}

	// Handle ignore/omit list (omit is alias for ignore)
	if len(opt.IgnoreList) > 0 && matchesTypeList(opt.IgnoreList, typeName) {
		return false
	}

	// Handle include list
	if len(opt.IncludeList) > 0 {
		return matchesTypeList(opt.IncludeList, typeName)
	}

	// Legacy behavior: check old boolean flags
	// Include if: (not ignored by ignoreAll AND not explicitly ignored/omitted) OR explicitly included
	return (!ignoreAll && !opt.Ignore && !opt.Omit) || opt.Include
}

// matchesTypeList checks if a typeName matches any entry in the list
// Returns true if list contains "*" or the exact typeName
func matchesTypeList(list []string, typeName string) bool {
	if len(list) == 0 {
		return false
	}
	for _, name := range list {
		if name == "*" || name == typeName {
			return true
		}
	}
	return false
}

// expandEmbeddedField recursively expands an embedded struct field into GraphQL fields
// func (g *Generator) expandEmbeddedField(f *ast.Field, d StructDirectives, ignoreAll bool, forInput bool) string {
// 	return g.expandEmbeddedFieldNamed(f, d, ignoreAll, forInput, "")
// }

// expandEmbeddedFieldNamed recursively expands an embedded struct field into GraphQL fields with type name
func (g *Generator) expandEmbeddedFieldNamed(f *ast.Field, d StructDirectives, ignoreAll bool, forInput bool, typeName string) string {
	// Get the type name of the embedded field
	var embeddedTypeName string
	switch t := f.Type.(type) {
	case *ast.Ident:
		embeddedTypeName = t.Name
	case *ast.StarExpr:
		// Handle pointer to embedded struct
		if ident, ok := t.X.(*ast.Ident); ok {
			embeddedTypeName = ident.Name
		}
	case *ast.SelectorExpr:
		// Handle embedded struct from another package (e.g., pkg.Type)
		embeddedTypeName = t.Sel.Name
	case *ast.IndexExpr:
		// Handle generic type with single type parameter (e.g., Connection[T])
		embeddedTypeName = g.extractGenericBaseName(t.X)
	case *ast.IndexListExpr:
		// Handle generic type with multiple type parameters (e.g., Map[K, V])
		embeddedTypeName = g.extractGenericBaseName(t.X)
	}

	if embeddedTypeName == "" {
		return "" // Unable to determine type name
	}

	// Look up the embedded struct in the parser
	embeddedStruct, exists := g.P.Structs[embeddedTypeName]
	if !exists {
		return "" // Embedded struct not found in parsed types
	}

	// If generating for input and the embedded type should be auto-generated as input,
	// mark it for generation
	if forInput {
		typeSpec := g.P.StructTypes[embeddedTypeName]
		if typeSpec != nil {
			genDecl := g.P.TypeToDecl[embeddedTypeName]
			directives := ParseDirectives(typeSpec, genDecl)
			if !directives.HasInputDirective && !directives.SkipType {
				g.AutoGeneratedInputs[embeddedTypeName] = true
			}
		}
	}

	// Recursively generate fields for the embedded struct
	// Create a minimal StructDirectives for the embedded type (no special directives)
	embeddedDirectives := StructDirectives{
		IgnoreAll: ignoreAll, // Inherit ignoreAll setting
	}

	return g.generateFieldsForTypeNamed(embeddedStruct, embeddedDirectives, false, forInput, typeName)
}

// extractGenericBaseName extracts the base type name from a generic type expression
// For example: Connection[T] -> "Connection", pkg.Edge[T] -> "Edge"
func (g *Generator) extractGenericBaseName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.SelectorExpr:
		// Handle package-qualified generic types (e.g., pkg.Type[T])
		return t.Sel.Name
	case *ast.StarExpr:
		// Handle pointer to generic type (e.g., *Connection[T])
		return g.extractGenericBaseName(t.X)
	}
	return ""
}

// extractBaseTypeName extracts the base type name from a GraphQL type string
// For example: "String!" -> "String", "[User!]!" -> "User", "PageInfo" -> "PageInfo"
func (g *Generator) extractBaseTypeName(graphQLType string) string {
	// Remove all !, [, and ] characters
	cleaned := strings.ReplaceAll(graphQLType, "!", "")
	cleaned = strings.ReplaceAll(cleaned, "[", "")
	cleaned = strings.ReplaceAll(cleaned, "]", "")
	cleaned = strings.TrimSpace(cleaned)

	// Check if it's a known scalar (built-in or custom)
	for _, scalar := range g.Config.KnownScalars {
		if scalar == cleaned {
			return "" // Known scalars are always in scope
		}
	}

	return cleaned
}

// isTypeInScope checks if a type name exists in the parsed types (structs or enums)
func (g *Generator) isTypeInScope(typeName string) bool {
	if typeName == "" {
		return true
	}

	// Check if it's a struct type
	if _, exists := g.P.StructTypes[typeName]; exists {
		return true
	}

	// Check if it's an enum type
	if _, exists := g.P.EnumTypes[typeName]; exists {
		return true
	}

	return false
}

// reportOutOfScopeTypes handles reporting and errors for types that are referenced but not in scope
func (g *Generator) reportOutOfScopeTypes() error {
	if len(g.OutOfScopeTypes) == 0 {
		return nil
	}

	action := g.Config.AutoGenerate.OutOfScopeTypes

	// Build a sorted list of out-of-scope types for consistent output
	typeNames := make([]string, 0, len(g.OutOfScopeTypes))
	for typeName := range g.OutOfScopeTypes {
		typeNames = append(typeNames, typeName)
	}
	sort.Strings(typeNames)

	// Build the message
	var msg strings.Builder
	msg.WriteString("\nOut-of-scope type references found:\n")
	msg.WriteString("=====================================\n")

	for _, typeName := range typeNames {
		refs := g.OutOfScopeTypes[typeName]
		// Sort by parent GQL name + field name for consistent output
		sort.Slice(refs, func(i, j int) bool {
			if refs[i].ParentGQLName != refs[j].ParentGQLName {
				return refs[i].ParentGQLName < refs[j].ParentGQLName
			}
			return refs[i].FieldName < refs[j].FieldName
		})

		msg.WriteString(fmt.Sprintf("\nType '%s' (not found in scanned packages) is referenced by:\n", typeName))
		for _, ref := range refs {
			// Look up the parent type in the registry to get full Go type path
			var parentGoTypeFull string
			for _, item := range g.GeneratedItems {
				if item.GQLName == ref.ParentGQLName {
					parentGoTypeFull = item.GoType
					break
				}
			}
			if parentGoTypeFull == "" {
				// Fallback if not found in registry
				parentGoTypeFull = ref.ParentGoType
			}

			msg.WriteString(fmt.Sprintf("  - %s.%s (GraphQL field)\n", ref.ParentGQLName, ref.FieldName))
			msg.WriteString(fmt.Sprintf("    Go: %s.%s (type: %s)\n", parentGoTypeFull, ref.GoFieldName, ref.GoFieldType))
		}
	}

	msg.WriteString("\nTo resolve this, you can:\n")
	msg.WriteString("  1. Add the package containing these types to your 'packages' configuration\n")
	msg.WriteString("  2. Map the fields to known types using custom type tags: gql:\"fieldName,type:KnownType\"\n")
	msg.WriteString("  3. Change 'out_of_scope_types' setting in config:\n")

	// Show current setting with indicator
	if action == OutOfScopeWarn {
		msg.WriteString("     - warn: Log warnings but continue (current)\n")
	} else {
		msg.WriteString("     - warn: Log warnings but continue\n")
	}
	if action == OutOfScopeFail {
		msg.WriteString("     - fail: Stop generation with error (current)\n")
	} else {
		msg.WriteString("     - fail: Stop generation with error\n")
	}
	if action == OutOfScopeIgnore {
		msg.WriteString("     - ignore: Allow undefined type references (current)\n")
	} else {
		msg.WriteString("     - ignore: Allow undefined type references\n")
	}
	if action == OutOfScopeExclude {
		msg.WriteString("     - exclude: Automatically exclude these fields from schema (current)\n")
	} else {
		msg.WriteString("     - exclude: Automatically exclude these fields from schema\n")
	}
	msg.WriteString("\n")

	switch action {
	case OutOfScopeFail:
		return fmt.Errorf("%s", msg.String())
	case OutOfScopeWarn:
		fmt.Fprintf(os.Stderr, "%s", msg.String())
	case OutOfScopeIgnore:
		// Do nothing - types are allowed even if undefined
	case OutOfScopeExclude:
		// Fields were already excluded during generation
		fmt.Fprintf(os.Stderr, "\nNote: %d field(s) were automatically excluded due to out-of-scope type references.\n", g.countExcludedFields())
		fmt.Fprintf(os.Stderr, "Set 'out_of_scope_types: ignore' if you want to include them anyway.\n\n")
	}

	return nil
}

// countExcludedFields counts the total number of fields that reference out-of-scope types
func (g *Generator) countExcludedFields() int {
	count := 0
	for _, refs := range g.OutOfScopeTypes {
		count += len(refs)
	}
	return count
}

// generateEnum generates a GraphQL enum definition from an EnumType
func (g *Generator) generateEnum(enumType *EnumType, ctx *GenerationContext) string {
	buf := strings.Builder{}

	// Add description if present
	if enumType.Description != "" {
		buf.WriteString(fmt.Sprintf("\"\"\"\n%s\n\"\"\"\n", enumType.Description))
	}

	buf.WriteString(fmt.Sprintf("enum %s", enumType.Name))

	// Add @goModel directive if gqlgen directives are enabled
	g.writeGoModelDirective(&buf, enumType.GoTypeName, false)

	buf.WriteString(" {\n")

	// Generate enum values
	for _, value := range enumType.Values {
		// Add description if present
		if value.Description != "" {
			buf.WriteString(fmt.Sprintf("  \"\"\"\n  %s\n  \"\"\"\n", value.Description))
		}

		// Add the enum value
		buf.WriteString(fmt.Sprintf("  %s", value.GraphQLName))

		// Add @goEnum directive if gqlgen directives are enabled
		if g.Config.UseGqlGenDirectives {
			// Use the package path where the const value is defined, not where the type is defined
			var valuePkgPath string
			if value.PackagePath != "" {
				// Use the stored package info for this specific const value
				valuePkgPath = g.P.GetPackageImportPathFromFile(value.PackagePath, value.PackageName, g.Config.ModelPath)
			} else {
				// Fallback to using the enum type's package (for backwards compatibility)
				valuePkgPath = g.P.GetPackageImportPath(enumType.GoTypeName, g.Config.ModelPath)
			}
			g.writeGoEnumDirective(&buf, valuePkgPath, value.GoName)
		}

		// Add deprecated directive if present
		g.writeDeprecatedDirective(&buf, value.Deprecated != "", value.Deprecated)

		buf.WriteString("\n")
	}

	buf.WriteString("}\n")

	// Register the generated enum
	g.registerGeneratedItem(GQLSchemaItem{
		OutputFile:    ctx.OutputFile,
		GoSourceFile:  g.P.EnumSourceFiles[enumType.GoTypeName],
		GoType:        enumType.GoTypeName,
		GoTypeName:    enumType.GoTypeName,
		GQLName:       enumType.Name,
		GQLKind:       "enum",
		Strategy:      ctx.Strategy,
		AutoGenerated: false, // Enums are not auto-generated
		Namespace:     ctx.Namespace,
	})

	return buf.String()
}
