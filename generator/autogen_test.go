package generator

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestAutoGenerateReferenced(t *testing.T) {
	tmpDir := t.TempDir()

	// Create test file with referenced types
	testFile := filepath.Join(tmpDir, "models.go")
	content := `package models

// PageInfo is referenced by CommentConnection but not annotated
type PageInfo struct {
	HasNextPage bool ` + "`json:\"hasNextPage\"`" + `
}

type Comment struct {
	ID   string ` + "`json:\"id\"`" + `
	Text string ` + "`json:\"text\"`" + `
}

/**
 * @gqlType
 */
type CommentConnection struct {
	PageInfo *PageInfo  ` + "`json:\"pageInfo\"`" + `
	Comments []*Comment ` + "`json:\"comments\"`" + `
	Count    int        ` + "`json:\"count\"`" + `
}
`

	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	parser := NewParser()
	if err := parser.Walk(tmpDir); err != nil {
		t.Fatalf("Walk() error = %v", err)
	}

	config := NewConfig()
	config.Output = filepath.Join(tmpDir, "schema.graphql")
	config.GenStrategy = GenStrategySingle
	config.AutoGenerate.Enabled = true
	config.AutoGenerate.Strategy = AutoGenReferenced
	config.AutoGenerate.MaxDepth = 1

	gen := NewGenerator(parser, config)
	if err := gen.Run(); err != nil {
		t.Fatalf("Run() error = %v", err)
	}

	generated, err := os.ReadFile(config.Output)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	schema := string(generated)

	// Should contain the explicitly annotated type
	if !strings.Contains(schema, "type CommentConnection") {
		t.Error("Schema should contain CommentConnection")
	}

	// Should contain auto-generated PageInfo (referenced by CommentConnection)
	if !strings.Contains(schema, "type PageInfo") {
		t.Error("Schema should auto-generate PageInfo type")
	}

	// Should contain auto-generated Comment (referenced by CommentConnection)
	if !strings.Contains(schema, "type Comment") {
		t.Error("Schema should auto-generate Comment type")
	}

	// Verify fields are present
	if !strings.Contains(schema, "hasNextPage:") {
		t.Error("PageInfo should have hasNextPage field")
	}
}

func TestAutoGenerateDepth(t *testing.T) {
	tmpDir := t.TempDir()

	testFile := filepath.Join(tmpDir, "models.go")
	content := `package models

type Level3 struct {
	Value string ` + "`json:\"value\"`" + `
}

type Level2 struct {
	Data *Level3 ` + "`json:\"data\"`" + `
}

type Level1 struct {
	Info *Level2 ` + "`json:\"info\"`" + `
}

/**
 * @gqlType
 */
type Root struct {
	Child *Level1 ` + "`json:\"child\"`" + `
}
`

	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	parser := NewParser()
	if err := parser.Walk(tmpDir); err != nil {
		t.Fatalf("Walk() error = %v", err)
	}

	config := NewConfig()
	config.Output = filepath.Join(tmpDir, "schema.graphql")
	config.GenStrategy = GenStrategySingle
	config.AutoGenerate.Enabled = true
	config.AutoGenerate.Strategy = AutoGenReferenced
	config.AutoGenerate.MaxDepth = 2 // Only go 2 levels deep

	gen := NewGenerator(parser, config)
	if err := gen.Run(); err != nil {
		t.Fatalf("Run() error = %v", err)
	}

	generated, err := os.ReadFile(config.Output)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	schema := string(generated)

	// Should contain Root (annotated)
	if !strings.Contains(schema, "type Root") {
		t.Error("Schema should contain Root")
	}

	// Should contain Level1 (depth 1)
	if !strings.Contains(schema, "type Level1") {
		t.Error("Schema should contain Level1")
	}

	// Should contain Level2 (depth 2)
	if !strings.Contains(schema, "type Level2") {
		t.Error("Schema should contain Level2")
	}

	// Should NOT contain Level3 (depth 3, exceeds maxDepth=2)
	if strings.Contains(schema, "type Level3") {
		t.Error("Schema should NOT contain Level3 (exceeds max depth)")
	}
}

func TestAutoGenerateDisabled(t *testing.T) {
	tmpDir := t.TempDir()

	testFile := filepath.Join(tmpDir, "models.go")
	content := `package models

type NotAnnotated struct {
	Value string ` + "`json:\"value\"`" + `
}

/**
 * @gqlType
 */
type Annotated struct {
	Ref *NotAnnotated ` + "`json:\"ref\"`" + `
}
`

	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	parser := NewParser()
	if err := parser.Walk(tmpDir); err != nil {
		t.Fatalf("Walk() error = %v", err)
	}

	config := NewConfig()
	config.Output = filepath.Join(tmpDir, "schema.graphql")
	config.GenStrategy = GenStrategySingle
	config.AutoGenerate.Enabled = false // Disabled

	gen := NewGenerator(parser, config)
	if err := gen.Run(); err != nil {
		t.Fatalf("Run() error = %v", err)
	}

	generated, err := os.ReadFile(config.Output)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	schema := string(generated)

	// Should contain annotated type
	if !strings.Contains(schema, "type Annotated") {
		t.Error("Schema should contain Annotated")
	}

	// Should NOT contain NotAnnotated (auto-gen disabled)
	if strings.Contains(schema, "type NotAnnotated") {
		t.Error("Schema should NOT auto-generate NotAnnotated when disabled")
	}
}

func TestAutoGenerateWithGqlIgnore(t *testing.T) {
	tmpDir := t.TempDir()

	testFile := filepath.Join(tmpDir, "models.go")
	content := `package models

/**
 * @gqlIgnore
 */
type IgnoredType struct {
	Value string ` + "`json:\"value\"`" + `
}

type AllowedType struct {
	Value string ` + "`json:\"value\"`" + `
}

/**
 * @gqlType
 */
type Main struct {
	Ignored *IgnoredType ` + "`json:\"ignored\"`" + `
	Allowed *AllowedType ` + "`json:\"allowed\"`" + `
}
`

	if err := os.WriteFile(testFile, []byte(content), 0644); err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	parser := NewParser()
	if err := parser.Walk(tmpDir); err != nil {
		t.Fatalf("Walk() error = %v", err)
	}

	config := NewConfig()
	config.Output = filepath.Join(tmpDir, "schema.graphql")
	config.GenStrategy = GenStrategySingle
	config.AutoGenerate.Enabled = true
	config.AutoGenerate.Strategy = AutoGenReferenced

	gen := NewGenerator(parser, config)
	if err := gen.Run(); err != nil {
		t.Fatalf("Run() error = %v", err)
	}

	generated, err := os.ReadFile(config.Output)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	schema := string(generated)

	// Should contain Main
	if !strings.Contains(schema, "type Main") {
		t.Error("Schema should contain Main")
	}

	// Should contain AllowedType
	if !strings.Contains(schema, "type AllowedType") {
		t.Error("Schema should contain AllowedType")
	}

	// Should NOT contain IgnoredType (has @gqlIgnore)
	if strings.Contains(schema, "type IgnoredType") {
		t.Error("Schema should NOT contain IgnoredType (has @gqlIgnore)")
	}
}
