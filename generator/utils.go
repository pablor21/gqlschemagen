package generator

import (
	"go/ast"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/pablor21/gqlschemagen/version"
)

// var GQLKEEP_REGEX = regexp.MustCompile(`(?s)# @gqlKeepBegin(.*?)# @gqlKeepEnd(?s)`)

// EnsureDir makes sure a directory exists
func EnsureDir(dir string) error {
	if dir == "" || dir == "." {
		return nil
	}
	return os.MkdirAll(dir, 0755)
}

func FileExists(path string) bool {
	info, err := os.Stat(path)
	return err == nil && !info.IsDir()
}

// FieldTypeName returns the bare type name used for nested type lookup
func FieldTypeName(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return FieldTypeName(t.X)
	case *ast.ArrayType:
		return FieldTypeName(t.Elt)
	case *ast.SelectorExpr:
		// package.Type -> Type
		return t.Sel.Name
	default:
		return ""
	}
}

// ExprToGraphQLType converts an ast.Expr to a GraphQL type string (with ! for required)
func ExprToGraphQLType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		switch t.Name {
		case "string":
			return "String!"
		case "int", "int32":
			return "Int!"
		case "int64":
			return "Int64!"
		case "float32", "float64":
			return "Float!"
		case "bool":
			return "Boolean!"
		case "interface{}":
			return "JSON!"
		case "Time", "time.Time":
			return "DateTime!"
		default:
			return t.Name + "!"
		}
	case *ast.StarExpr:
		return ExprToGraphQLType(t.X)
	case *ast.ArrayType:
		return "[" + ExprToGraphQLType(t.Elt) + "]!"
	case *ast.SelectorExpr:
		return t.Sel.Name + "!"
	default:
		return "String!"
	}
}

func WriteFile(path, content string, config *Config) error {
	// Ensure parent dir exists
	dir := filepath.Dir(path)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0o755); err != nil {
			return err
		}
	}

	// check for # @gqlKeepBegin and # @gqlKeepEnd markers to preserve content (can have multiple)
	if FileExists(path) {
		var preservedSections []string
		var gqlKeepRegex = regexp.MustCompile(`(?s)` + config.KeepBeginMarker + `(.*?)` + config.KeepEndMarker + `(?s)`)
		existingContent, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		existingStr := string(existingContent)
		matches := gqlKeepRegex.FindAllStringSubmatch(existingStr, -1)
		for _, match := range matches {
			if len(match) < 2 {
				continue
			}
			innerContent := match[1]
			// Replace the corresponding section in content
			preservedSections = append(preservedSections, innerContent)
		}

		if len(preservedSections) > 0 {
			combinedSections := config.KeepBeginMarker + strings.Join(preservedSections, "\n") + config.KeepEndMarker

			// Depending on placement config, insert preserved sections
			if config.KeepSectionPlacement == "start" {
				content = combinedSections + "\n" + content
			} else {
				content = content + "\n" + combinedSections + "\n"
			}
		} else {
			placeholder := config.KeepBeginMarker + "\n# You can add custom types or comments here and they will be preserved during code generation.\n" + config.KeepEndMarker
			// Depending on placement config, insert placeholder markers
			if config.KeepSectionPlacement == "start" {
				content = placeholder + "\n\n" + content
			} else {
				content = content + "\n\n" + placeholder + "\n\n"
			}
		}
	}

	// add a notice at the top
	content = "# Code generated by https://github.com/pablor21/gqlschemagen " + version.Get() + ".\r\n" +
		"# PUT YOUR CUSTOM CONTENT BETWEEN @gqlKeep(Begin|End) markers, see:  https://github.com/pablor21/gqlschemagen#keeping-schema-modifications \n" + content

	// Write file (atomic write could be added if desired)
	return os.WriteFile(path, []byte(content), 0o644)
}

// helper to normalize package dir path for go run usage
func PkgDir(in string) string {
	if strings.HasPrefix(in, "./") || strings.HasPrefix(in, "/") {
		return in
	}
	// fallback - treat as local path
	return in
}
