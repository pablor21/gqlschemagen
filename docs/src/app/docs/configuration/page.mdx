import NextButton from "@/components/docs/next-button";

export const metadata = {
  title: "Configuration",
  description:
    "Learn how to configure GQLSchemaGen using a YAML file to control output paths, markers, namespaces, enums, and more.",
};

# **Configuration**

Before generating schemas, you need (no you don't actually *need*, but you **want**, trust me!) to tell **GQLSchemaGen** how your project is structured and how you want the output organized.
Running:

<Snippet>gqlschemagen init</Snippet>

creates a `gqlschemagen.yml` file in your project root. This file controls:

- which Go packages are scanned
- how output files are structured
- type and field naming rules
- enum generation
- auto-generation behavior
- gqlgen integration options
- file-preservation rules via `@gqlKeep` markers

Configure this once and the tool handles the rest.

---

# **1. Packages & Strategy**

## **Packages**

Define the Go packages where annotated structs (`@gqlType`, `@gqlInput`, `@gqlEnum`) are located. Supports glob patterns for recursive scanning.

```yaml
packages:
  - ./graph/model/
  - ./internal/domain/
  - ./pkg/dto/**/*.go  # Recursive glob pattern
```

**Examples:**
- `./models/` - Scan models directory
- `./internal/**/*.go` - Recursively scan all Go files in internal
- `./pkg/types/user.go` - Scan specific file

## **Output Strategy**

Controls how schema files are generated:

| Strategy   | Behavior | Use Case |
| ---------- | -------- | -------- |
| `single`   | One schema file for everything | Small projects, simple schemas |
| `multiple` | One file per GraphQL type | Large schemas, parallel development |
| `package`  | One file per Go package | Monorepo, module-based organization |

```yaml
strategy: multiple
```

**Examples:**

**Single strategy** - all types in one file:
```
graph/schema/
  └── gqlschemagen.graphqls  # User, Product, Order, etc.
```

**Multiple strategy** - separate files:
```
graph/schema/
  ├── User.graphqls
  ├── Product.graphqls
  └── Order.graphqls
```

**Package strategy** - organized by Go package:
```
graph/schema/
  ├── models.graphqls      # Types from internal/models
  ├── dto.graphqls         # Types from internal/dto
  └── domain.graphqls      # Types from pkg/domain
```

---

# **2. Output Structure**

## **Output Path**

Directory or file path where schema files will be generated. The meaning depends on your strategy:

- **Single strategy**: Full file path including filename
- **Multiple/Package strategy**: Directory path

```yaml
# Single strategy
output: graph/schema/schema.graphqls

# Multiple/Package strategy  
output: graph/schema/
```

## **Output File Name**

Controls the filename when using `single` strategy:

```yaml
output_file_name: gqlschemagen.graphqls
```

Default: `gqlschemagen.graphqls`

## **Output File Extension**

File extension for generated schema files in `multiple` and `package` strategies:

```yaml
output_file_extension: .graphqls
```

Default: `.graphqls`

Common alternatives: `.gql`, `.graphql`

## **Schema File Name Pattern**

Customize file naming in `multiple` strategy using placeholders:

```yaml
schema_file_name: "{model_name}.graphqls"
```

**Available placeholders:**
- `{model_name}` - Go struct name (e.g., `User` → `User.graphqls`)
- `{type_name}` - GraphQL type name (e.g., `UserProfile` → `UserProfile.graphqls`)

**Examples:**
```yaml
# Default
schema_file_name: "{model_name}.graphqls"
# Result: User.graphqls, Product.graphqls

# With prefix
schema_file_name: "type_{model_name}.graphqls"  
# Result: type_User.graphqls, type_Product.graphqls

# Lowercase
schema_file_name: "{model_name}_schema.graphqls"
# Result: user_schema.graphqls (if you implement lowercase conversion)
```

---

# **3. Naming Conventions**

## **Field Case Transformation**

Controls how Go struct field names are converted to GraphQL field names:

```yaml
field_case: camel
```

**Options:**

| Option     | Go Field   | GraphQL Field | Description |
|------------|------------|---------------|-------------|
| `camel`    | `UserName` | `userName`    | camelCase (recommended) |
| `snake`    | `UserName` | `user_name`   | snake_case |
| `pascal`   | `UserName` | `UserName`    | PascalCase |
| `original` | `UserName` | `UserName`    | Keep as-is |
| `none`     | `userName` | `userName`    | No transformation |

**Example:**
```go
// Go struct
type User struct {
    FirstName string
    LastName  string
    EmailAddress string
}
```

```graphql
# field_case: camel
type User {
  firstName: String!
  lastName: String!
  emailAddress: String!
}

# field_case: snake
type User {
  first_name: String!
  last_name: String!
  email_address: String!
}
```

## **Use JSON Tags**

When enabled, uses `json:"..."` struct tags for field names if `gql:"..."` tags are not present:

```yaml
use_json_tag: true
```

**Example:**
```go
type User struct {
    ID       string `json:"id"`
    FullName string `json:"full_name"`
    Internal string `json:"-"`  // Ignored (json:"-" rule)
}
```

```graphql
type User {
  id: String!
  full_name: String!
  # Internal field is excluded
}
```

## **Type Name Manipulation**

### Strip Prefix/Suffix

Remove common prefixes or suffixes from type names:

```yaml
strip_prefix: "DB,Pg,Api"
strip_suffix: "DTO,Entity,Model"
```

**Example:**
```go
type DBUser struct {}      // → User
type PgProduct struct {}   // → Product  
type OrderDTO struct {}    // → Order
type UserEntity struct {}  // → User
```

### Add Type Prefix/Suffix

Add prefixes or suffixes to GraphQL **output** type names:

```yaml
add_type_prefix: "Gql"
add_type_suffix: "Type"
```

**Example:**
```go
// @gqlType
type User struct {}
```

```graphql
# With add_type_prefix: "Gql"
type GqlUser { ... }

# With add_type_suffix: "Type"  
type UserType { ... }

# With both
type GqlUserType { ... }
```

### Add Input Prefix/Suffix

Add prefixes or suffixes to GraphQL **input** type names:

```yaml
add_input_prefix: ""
add_input_suffix: "Input"
```

**Example:**
```go
// @gqlInput(name:"CreateUser")
type CreateUserDTO struct {}
```

```graphql
# With add_input_suffix: "Input"
input CreateUserInput { ... }

# With add_input_prefix: "Gql" and suffix: "Payload"
input GqlCreateUserPayload { ... }
```

**Note:** These only apply when `@gqlType` or `@gqlInput` don't specify a custom `name` parameter.

---

# **4. Directives & gqlgen Integration**

## **Enable gqlgen Directives**

Generate [gqlgen](https://gqlgen.com/)-compatible directives for seamless integration:

```yaml
use_gqlgen_directives: true
```

When enabled, generates:
- **`@goModel`** - Maps GraphQL type to Go struct
- **`@goField`** - Configures resolver behavior
- **`@goTag`** - Adds Go struct tags to generated code

**Example output:**
```graphql
type User @goModel(model: "github.com/myapp/models.User") {
  id: ID! @goField(forceResolver: true)
  email: String! @goTag(key: "validate", value: "email")
}

enum Status @goModel(model: "github.com/myapp/models.Status") {
  ACTIVE @goEnum(value: "github.com/myapp/models.StatusActive")
  INACTIVE @goEnum(value: "github.com/myapp/models.StatusInactive")
}
```

## **Model Path Override**

Override the base import path used in `@goModel` directives:

```yaml
model_path: "github.com/mycompany/myapp/models"
```

**When to use:**
- Generating schemas for a different module path than source location
- Standardizing import paths across environments
- Building schemas for code generation

**Example:**
```go
// Actual package: github.com/dev/prototype/models
// But you want: github.com/mycompany/production/models

// Config:
model_path: "github.com/mycompany/production/models"
```

```graphql
# Generated:
type User @goModel(model: "github.com/mycompany/production/models.User") {
  # ...
}
```

**Default behavior:** When empty (`""`), uses the actual package import path from `go.mod`.

---

# **5. Auto-Generation**

GQLSchemaGen can automatically generate schemas for types referenced by annotated types, reducing manual `@gqlType` annotations.

## **Enable Auto-Generation**

```yaml
auto_generate:
  enabled: true
  strategy: referenced  # recommended
```

## **Strategies**

### `none` - Manual Only
Only generate types explicitly marked with `@gqlType`, `@gqlInput`, or `@gqlInclude`:

```yaml
auto_generate:
  enabled: true
  strategy: none
```

**Use case:** Full control, minimal schema

### `referenced` - Smart Dependencies (Recommended)
Auto-generate types referenced by annotated types:

```yaml
auto_generate:
  enabled: true
  strategy: referenced
  max_depth: 1
  only_referenced_by_annotated: true
```

**Example:**
```go
// @gqlType - Explicitly annotated
type User struct {
    ID      string
    Profile UserProfile  // Auto-generated
    Posts   []Post       // Auto-generated
}

type UserProfile struct {
    Bio    string
    Avatar string
}

type Post struct {
    Title   string
    Content string
}
```

**Generated:** `User`, `UserProfile`, and `Post` types

### `all` - Generate Everything
Generate schemas for all structs found in scanned packages:

```yaml
auto_generate:
  enabled: true
  strategy: all
```

**Use case:** Comprehensive API documentation, exploratory schemas

**Warning:** May generate types you don't want exposed

### `patterns` - Pattern Matching
Generate based on glob patterns:

```yaml
auto_generate:
  enabled: true
  strategy: patterns
  patterns:
    - "*/models/*Connection"
    - "*/models/*Edge"
    - "*/dto/*Input"
  exclude_patterns:
    - "*/internal/*"
    - "*/*_test.go"
```

**Use case:** Convention-based generation (e.g., all types ending with "Connection")

## **Max Depth**

Controls how deep to traverse type dependencies:

```yaml
auto_generate:
  max_depth: 2
```

- `0` - Unlimited depth
- `1` - Direct references only (recommended)
- `2` - Direct + transitive references
- `3+` - Further nesting

**Example with max_depth: 1:**
```go
// @gqlType
type User struct {
    Profile UserProfile  // ✓ Generated (depth 1)
}

type UserProfile struct {
    Settings UserSettings  // ✗ NOT generated (depth 2)
}
```

**Example with max_depth: 2:**
```go
// @gqlType
type User struct {
    Profile UserProfile  // ✓ Generated (depth 1)
}

type UserProfile struct {
    Settings UserSettings  // ✓ Generated (depth 2)
}

type UserSettings struct {
    Theme ThemeConfig  // ✗ NOT generated (depth 3)
}
```

## **Include Options**

### Include Embedded Types
Auto-generate schemas for embedded struct types:

```yaml
auto_generate:
  include_embedded: true
```

```go
type Timestamps struct {
    CreatedAt time.Time
    UpdatedAt time.Time
}

// @gqlType
type User struct {
    Timestamps  // ✓ Timestamps type auto-generated
    Name string
}
```

### Include Field Types
Auto-generate schemas for field types:

```yaml
auto_generate:
  include_field_types: true
```

```go
// @gqlType
type User struct {
    Address Address  // ✓ Address type auto-generated
}

type Address struct {
    Street string
    City   string
}
```

## **Out-of-Scope Types**

Controls behavior when types are referenced but not in scanned packages:

```yaml
auto_generate:
  out_of_scope_types: warn  # or fail, ignore, exclude
```

**Options:**

| Option    | Behavior |
|-----------|----------|
| `warn`    | Log warnings, keep field (default) |
| `fail`    | Stop generation with error |
| `ignore`  | Silently allow, keep field |
| `exclude` | Remove fields with out-of-scope types |

**Example:**
```go
// In scanned package
// @gqlType
type User struct {
    ID      string
    Company external.Company  // Not in scanned packages
}
```

- **warn**: Generates `User` type with `Company` field, shows warning
- **fail**: Generation stops with error
- **ignore**: Generates `User` type silently
- **exclude**: Generates `User` without `Company` field

## **Generic Type Handling**

### Unresolved Generic Type
What to use when generic type parameters can't be resolved:

```yaml
auto_generate:
  unresolved_generic_type: "Any"  # or "JSON", or any scalar
```

```go
type Result[T any] struct {
    Data T
    Error string
}

// If T cannot be resolved:
```

```graphql
# With unresolved_generic_type: "Any"
type Result {
  data: Any
  error: String!
}

# With unresolved_generic_type: "JSON"  
type Result {
  data: JSON
  error: String!
}
```

### Suppress Generic Warnings
Suppress out-of-scope warnings for type parameters (`T`, `K`, `V`, etc.):

```yaml
auto_generate:
  suppress_generic_type_warnings: true
```

Useful when working with generic types where type parameters are expected to be unresolved.

---

# **6. Known Scalars & Scalar Mappings**

## **Known Scalars**

List custom GraphQL scalars that are defined externally (in other schemas or libraries). These types are considered "in scope" and won't trigger out-of-scope warnings:

```yaml
known_scalars:
  - DateTime
  - UUID
  - JSON
  - Upload
  - Decimal
```

**When to use:**
- Using custom scalars defined in separate schema files
- Integrating with third-party GraphQL libraries
- Using scalars from gqlgen or other tools

**Example:**
```go
type User struct {
    CreatedAt DateTime  // Won't warn if DateTime is in known_scalars
    Metadata  JSON      // Won't warn if JSON is in known_scalars
}
```

**Built-in scalars** (always known): `Int`, `Float`, `String`, `Boolean`, `ID`

## **Scalar Mappings**

Map Go types to GraphQL scalars globally. Similar to gqlgen's `models` configuration:

```yaml
scalars:
  ID:
    model:
      - github.com/google/uuid.UUID
      - github.com/gofrs/uuid.UUID
  DateTime:
    model:
      - time.Time
  Int64:
    model:
      - int64
```

**How it works:**

1. When a field has a Go type matching a `model` entry, use the scalar instead of generating a new type
2. Scalar declarations are **only** generated for scalars that are:
   - Used in the schema
   - NOT built-in (`Int`, `String`, `Float`, `Boolean`, `ID`)
   - NOT in `known_scalars`

**Example:**

```go
import (
    "time"
    "github.com/gofrs/uuid"
)

// @gqlType
type User struct {
    ID        uuid.UUID   // Maps to ID scalar
    Name      string      // Maps to String
    CreatedAt time.Time   // Maps to DateTime scalar
}
```

**Generated schema:**
```graphql
scalar DateTime

type User {
  id: ID!
  name: String!
  createdAt: DateTime!
}
```

**Why `DateTime` is declared but `ID` is not:**
- `ID` is a built-in GraphQL scalar
- `DateTime` is custom and not in `known_scalars`, so it needs declaration

**Multiple UUID libraries:**
```yaml
scalars:
  ID:
    model:
      - github.com/google/uuid.UUID
      - github.com/gofrs/uuid.UUID
      - github.com/satori/go.uuid.UUID
```

All three UUID libraries map to the same `ID` scalar, ensuring consistency.

---

# **8. File Preservation (GQLKeep)**

Preserve sections between regenerations:

```yaml
keep_section_placement: "end"
keep_begin_marker: "# @gqlKeepBegin"
keep_end_marker: "# @gqlKeepEnd"
```

Place custom code between markers in your schema files and it won’t be overwritten.

---

# **9. CLI & Watcher Settings**

Configure file-watching for automatic schema regeneration during development.

## **Enable Watch Mode**

```yaml
cli:
  watcher:
    enabled: true
    debounce_ms: 500
```

**Usage:**
```bash
gqlschemagen generate --watch
```

The tool monitors configured packages and regenerates schemas on file changes.

## **Debounce Delay**

Delay in milliseconds before regenerating after file changes:

```yaml
cli:
  watcher:
    debounce_ms: 500  # Wait 500ms after last change
```

**Recommended values:**
- `100-300ms` - Fast feedback, may trigger multiple times
- `500ms` - Balanced (default)
- `1000ms+` - Slower, fewer regenerations

## **Additional Paths**

Monitor additional directories beyond configured `packages`:

```yaml
cli:
  watcher:
    additional_paths:
      - ./config/
      - ./pkg/types/
```

**Use case:** Watch configuration files or shared type definitions.

## **Ignore Patterns**

Exclude directories from watching:

```yaml
cli:
  watcher:
    ignore_patterns:
      - vendor
      - node_modules
      - .git
      - "*_test.go"
      - "*.tmp"
```

**Default patterns:** `vendor`, `node_modules`, `.git`

## **Watch Mode Example**

Complete watcher configuration:

```yaml
cli:
  watcher:
    enabled: true
    debounce_ms: 300
    additional_paths:
      - ./shared/types/
    ignore_patterns:
      - vendor
      - node_modules
      - .git
      - "*_test.go"
      - .history
```

**Terminal output:**
```bash
$ gqlschemagen generate --watch

[INFO] Watching for changes...
[INFO] File changed: internal/models/user.go
[INFO] Regenerating schema...
[SUCCESS] Schema generated successfully
[INFO] Watching for changes...
```

---

# **Generate Your Schema**

Once the config is set up:

<Snippet>gqlschemagen generate</Snippet>

This processes all annotated structs and outputs schema files according to your chosen strategy.

Example output:

<CodeBlock className="mt-4" language="graphql" filename="schema.graphqls">
  {`"""
  Represents a user in the system
  """
  type UserProfile @goModel(model: "your-package.User") {
    id: ID!
    name: String!
  }`}
</CodeBlock>

---

## Full Example Configuration

Below is the complete recommended config.

<Collapsible title="Full Example: gqlschemagen.yml" label="Full Configuration">
    <CodeBlock language="yaml" filename="gqlschemagen.yml">
{`# gqlschemagen Configuration

tool_version: "0.1.11"

# Packages to scan for Go structs with gql annotations (required)
# Supports direct paths to directories containing Go files
packages:
   - ./

# Output strategy: "single" for one file, "multiple" for separate files per type, "package" for separate files per package
# Options: "single", "multiple", "package"
# Default: "multiple"
strategy: single

# Output path (directory or file path depending on strategy)
output: graph/schema/

# Output file name when using single strategy
# Default: "gqlschemagen.graphqls"
output_file_name: gqlschemagen.graphqls

# Output file extension for multiple/package strategies
# Default: ".graphqls"
output_file_extension: .graphqls

# Field name transformation: camel, snake, pascal, original, none
# - camel: FirstName -> firstName
# - snake: FirstName -> first_name  
# - pascal: FirstName -> FirstName
# - original: Keep as defined in struct
# - none: Keep struct field name untouched
# Default: "camel"
field_case: camel

# Use json struct tags for field names when gql tag is not present
# This will follow the ignore rules of the json package (e.g., json:"-" to ignore fields)
# Default: true
use_json_tag: true 

# Generate gqlgen directives (@goModel, @goField, @goTag)
# Default: false
use_gqlgen_directives: false

# Base path for @goModel directive (leave empty to use actual package path)
# This is only used in the scanned packages, external packages always use their real import path.
# Example: "github.com/user/project/models"
# Default: "" (empty - auto-detected from go.mod)
model_path: ""

# Strip prefixes from type names (e.g., "DB,Pg" converts DBUser -> User)
# Only applies when @gqlType or @gqlInput doesn't specify a custom name
# Default: "" (empty)
strip_prefix: ""

# Strip suffixes from type names (e.g., "DTO,Entity" converts UserDTO -> User)
# Only applies when @gqlType or @gqlInput doesn't specify a custom name
# Default: "" (empty)
strip_suffix: ""

# Add prefix to GraphQL type names (e.g., "Gql" converts User -> GqlUser)
# Only applies when @gqlType doesn't specify a custom name
# Default: "" (empty)
add_type_prefix: ""

# Add suffix to GraphQL type names (e.g., "Type" converts User -> UserType)
# Only applies when @gqlType doesn't specify a custom name
# Default: "" (empty)
add_type_suffix: ""

# Add prefix to GraphQL input names
# Only applies when @gqlInput doesn't specify a custom name
# Default: "" (empty)
add_input_prefix: ""

# Add suffix to GraphQL input names (e.g., "Input" converts CreateUser -> CreateUserInput)
# Only applies when @gqlInput doesn't specify a custom name
# Default: "Input"
add_input_suffix: "Input"

# Schema file name pattern for multiple strategy (supports: {model_name}, {type_name})
# Example: "{type_name}.graphqls" or "{model_name}_schema.graphqls"
# Default: "{model_name}.graphqls"
schema_file_name: "{model_name}.graphqls"

# Include types with no fields in the generated schema
# Default: false
include_empty_types: false

# Skip overwriting existing files when generating
# Default: false
skip_existing: false

# Automatically generate input types from structs with @gqlType
# Default: true
gen_inputs: true

# Generate empty structs (types with no fields)
# Default: false
generate_empty_structs: false

# Namespace separator for converting namespace to file paths
# Example: "/" converts "user.auth" to "user/auth.graphqls"
# Default: "/"
namespace_separator: "/"

# Known GraphQL scalar types (built-in + custom)
# These types are always considered "in scope" and won't trigger out-of-scope warnings
# You can add your own custom scalars here (e.g., "Money", "Color", "URL")
# Default: includes GraphQL built-ins (Int, Float, String, Boolean, ID) and common customs
known_scalars:
   - Int
   - Float
   - String
   - Boolean
   - ID
   - Time
   - DateTime
   - Date
   - Timestamp
   - Upload
   - Map
   - UUID
   - Any
   - JSON
   - Byte
   - Bytes
   - Int64
   - UInt
   - UInt64

# Scalar type mappings (similar to gqlgen models)
# Maps Go types (by full package path) to GraphQL scalars
# This allows you to map types like uuid.UUID to GraphQL ID globally
# Example:
# scalars:
#   ID:
#     model:
#       - github.com/google/uuid.UUID
#       - github.com/gofrs/uuid.UUID
#   DateTime:
#     model:
#       - time.Time
#   Int64:
#     model:
#       - int64
#
# When a Go type matches a model entry, the field will use the scalar type
# instead of generating a new type. Scalar declarations are auto-generated ONLY
# for scalars that are NOT built-in (ID, String, Int, Float, Boolean) and NOT
# in known_scalars section.
scalars:
  # ID:
  #   model:
  #     - github.com/google/uuid.UUID
  # DateTime:
  #   model:
  #     - time.Time

# GQLKeep preserved sections configuration
# Allows you to preserve custom content between regenerations
# Add content between @gqlKeepBegin and @gqlKeepEnd markers in your schema

# Placement of the preserved sections (options: "start", "end")
# Default: "end"
keep_section_placement: "end"

# Markers to denote beginning and end of preserved sections
# Default: "# @gqlKeepBegin"
keep_begin_marker: "# @gqlKeepBegin"
# Default: "# @gqlKeepEnd"
keep_end_marker: "# @gqlKeepEnd"

# Auto-generation configuration
# Automatically generate GraphQL types for structs referenced by annotated types
auto_generate:
   # Enable/disable auto-generation
   # Default: true
   enabled: true
   
   # Strategy for auto-generation:
   # - "none": Disable auto-generation
   # - "referenced": Auto-generate types referenced by annotated types (recommended)
   # - "all": Auto-generate all structs found
   # - "patterns": Auto-generate types matching patterns list
   # Default: "referenced"
   strategy: referenced
   
   # Maximum depth for dependency traversal
   # 0 = unlimited, 1 = direct references only, 2 = direct + transitive
   # Default: 1
   max_depth: 1
   
   # Patterns for type matching (only used when strategy is "patterns")
   # Example: ["*/models/*Connection", "*/graph/model/*Input"]
   # Default: [] (empty)
   patterns: []
   
   # Exclude patterns (applied to all strategies)
   # Example: ["*/internal/*", "*/vendor/*"]
   # Default: ["*/vendor/*", "*/*_test.go"]
   exclude_patterns:
      - "*/vendor/*"
      - "*/*_test.go"
   
   # Only auto-generate types that are referenced by @gql* annotated types
   # Default: true
   only_referenced_by_annotated: true
   
   # Auto-generate embedded struct types
   # Default: true
   include_embedded: true
   
   # Auto-generate field types
   # Default: true
   include_field_types: true
   
   # Action for out-of-scope types (types referenced but not in scanned packages)
   # Options: "warn", "fail", "ignore", "exclude"
   # - "warn": Log warnings about out-of-scope types (default)
   # - "fail": Stop generation if out-of-scope types are found
   # - "ignore": Silently allow out-of-scope type references
   # - "exclude": Automatically exclude fields with out-of-scope types
   # Default: "warn"
   out_of_scope_types: warn
   
   # Type to use for unresolved generic type parameters
   # When a generic type parameter cannot be resolved (e.g., T in Result[T] when used standalone),
   # this determines what GraphQL type to use instead
   # Default: "" (keeps as-is, e.g., "T")
   # Common values: "Any", "JSON", or any custom scalar name
   unresolved_generic_type: ""
   
   # Suppress out-of-scope warnings for common type parameters (T, K, V, etc.)
   # Useful when using generic types where type parameters are expected to be unresolved
   # Default: false
   suppress_generic_type_warnings: false

# CLI configuration
cli:
   # File watcher configuration
   watcher:
      # Enable watch mode
      # Default: false
      enabled: false
      
      # Debounce delay in milliseconds
      # Default: 500
      debounce_ms: 500
      
      # Additional paths to watch (beyond packages)
      # Default: [] (empty)
      additional_paths: []
      
      # Paths/patterns to ignore
      # Default: ["vendor", "node_modules", ".git"]
      ignore_patterns:
         - vendor
         - node_modules
         - .git
`}

</CodeBlock>
</Collapsible>

---

To learn how to annotate your structs and generate your first types, continue to the [GQL Types guide](/docs/features/gql-types).

<NextButton href="/docs/features/gql-types">GQL Types</NextButton>
