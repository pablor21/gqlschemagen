import NextButton from "@/components/docs/next-button";

export const metadata = {
  title: "Configuration",
  description:
    "Learn how to configure GQLSchemaGen using a YAML file to control output paths, markers, namespaces, enums, and more.",
};

# **Configuration**

Before generating schemas, you need to tell **GQLSchemaGen** how your project is structured and how you want the output organized.
Running:

<Snippet>gqlschemagen init</Snippet>

creates a `gqlschemagen.yml` file in your project root. This file controls:

- which Go packages are scanned
- how output files are structured
- type and field naming rules
- enum generation
- auto-generation behavior
- gqlgen integration options
- file-preservation rules via `@gqlKeep` markers

Configure this once and the tool handles the rest.

---

# **1. Packages & Strategy**

## **Packages**

Define the Go packages where annotated structs (`@gqlType`, `@gqlInput`, `@gqlEnum`) are located.

```yaml
packages:
  - ./graph/model/
  - ./domain/
```

## **Output Strategy**

Controls how schema files are generated:

| Strategy   | Meaning                        |
| ---------- | ------------------------------ |
| `single`   | One schema file for everything |
| `multiple` | One file per GraphQL type      |
| `package`  | One file per Go package        |

```yaml
strategy: multiple
```

---

# **2. Output Structure**

## **Output Path**

Directory or file path depending on strategy:

```yaml
output: graph/schema/
```

## **File Naming**

Applies when using `single` or when customizing file names in multi-file modes.

```yaml
output_file_name: gqlschemagen.graphqls
output_file_extension: .graphqls
schema_file_name: "{model_name}.graphqls"
```

---

# **3. Naming Conventions**

## **Field Case Transformation**

How struct field names are turned into GraphQL field names:

```yaml
field_case: camel
```

Options: `camel`, `snake`, `pascal`, `original`, `none`.

## **Use JSON Tags**

Use `json:"..."` tags when `gql` tags are missing.

```yaml
use_json_tag: true
```

## **Type Name Manipulation**

Prefixes & suffixes for type or input names:

```yaml
strip_prefix: ""
strip_suffix: ""

add_type_prefix: ""
add_type_suffix: ""

add_input_prefix: ""
add_input_suffix: "Input"
```

---

# **4. Directives & gqlgen Integration**

Enable or disable generation of gqlgen-compatible helpers:

```yaml
use_gqlgen_directives: false
model_path: ""
```

If enabled, it generates:

- `@goModel`
- `@goField`
- `@goTag`

---

# **5. Auto-Generation (Dependencies)**

GQLSchemaGen can generate types referenced by other annotated types.

```yaml
auto_generate:
  enabled: true
  strategy: referenced
  max_depth: 1
  include_embedded: true
  include_field_types: true
  only_referenced_by_annotated: true
  out_of_scope_types: warn
```

**Strategies:**

- `none`
- `referenced` (recommended)
- `all`
- `patterns`

---

# **6. Enum Support**

Enum generation is handled via:

- `@gqlEnum` on type declarations
- `@gqlEnumValue` on individual constants
- Supports string and iota enums

Nothing special is required in the config, but the config file documents supported features.

---

# **7. Known Scalars**

Add custom scalars to avoid out-of-scope warnings:

```yaml
known_scalars:
  - ID
  - DateTime
  - UUID
  - JSON
  - Bytes
```

---

# **8. File Preservation (GQLKeep)**

Preserve sections between regenerations:

```yaml
keep_section_placement: "end"
keep_begin_marker: "# @gqlKeepBegin"
keep_end_marker: "# @gqlKeepEnd"
```

Place custom code between markers in your schema files and it wonâ€™t be overwritten.

---

# **9. CLI & Watcher Settings**

Optional file-watching:

```yaml
cli:
  watcher:
    enabled: false
    debounce_ms: 500
    additional_paths: []
    ignore_patterns:
      - vendor
      - node_modules
      - .git
```

---

# **Generate Your Schema**

Once the config is set up:

<Snippet>gqlschemagen generate</Snippet>

This processes all annotated structs and outputs schema files according to your chosen strategy.

Example output:

<CodeBlock className="mt-4" language="graphql" filename="schema.graphqls">
  {`"""
  Represents a user in the system
  """
  type UserProfile @goModel(model: "your-package.User") {
    id: ID!
    name: String!
  }`}
</CodeBlock>

---

## Full Example Configuration

Below is the complete recommended config.

<Collapsible title="Full Example: gqlschemagen.yml" label="Full Configuration">
    <CodeBlock language="yaml" filename="gqlschemagen.yml">
{`# gqlschemagen Configuration
tool_version: "v0.1.16"

packages:
  - ./graph/model/
  - ./domain/

strategy: multiple
output: graph/schema/
output_file_name: gqlschemagen.graphqls
output_file_extension: .graphqls
schema_file_name: "{model_name}.graphqls"

field_case: camel
use_json_tag: true

use_gqlgen_directives: false
model_path: ""

strip_prefix: ""
strip_suffix: ""
add_type_prefix: ""
add_type_suffix: ""
add_input_prefix: ""
add_input_suffix: "Input"

include_empty_types: false
skip_existing: false
gen_inputs: true
generate_empty_structs: false

namespace_separator: "/"

known_scalars:
  - Int
  - Float
  - String
  - Boolean
  - ID
  - Time
  - DateTime
  - Date
  - Timestamp
  - Upload
  - Map
  - UUID
  - Any
  - JSON
  - Byte
  - Bytes
  - Int64
  - UInt
  - UInt64

keep_section_placement: "end"
keep_begin_marker: "# @gqlKeepBegin"
keep_end_marker: "# @gqlKeepEnd"

auto_generate:
  enabled: true
  strategy: referenced
  max_depth: 1
  patterns: []
  exclude_patterns:
    - "*/vendor/*"
    - "*/*_test.go"
  only_referenced_by_annotated: true
  include_embedded: true
  include_field_types: true
  out_of_scope_types: warn

cli:
  watcher:
    enabled: false
    debounce_ms: 500
    additional_paths: []
    ignore_patterns:
      - vendor
      - node_modules
      - .git
`}

</CodeBlock>
</Collapsible>

---

To learn how to annotate your structs and generate your first types, continue to the [GQL Types guide](/docs/features/gql-types).

<NextButton href="/docs/features/gql-types">GQL Types</NextButton>
