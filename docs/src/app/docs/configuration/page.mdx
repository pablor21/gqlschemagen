import NextButton from "@/components/docs/next-button";

export const metadata = {
  title: "Configuration",
  description:
    "Learn how to configure GQLSchemaGen using a YAML file to control output paths, markers, namespaces, enums, and more.",
};

# **Configuration**

Before generating schemas, you need to tell **GQLSchemaGen** how your project is structured and how you want the output organized.
Running:

<Snippet>gqlschemagen init</Snippet>

creates a `gqlschemagen.yml` file in your project root. This file controls:

- which Go packages are scanned
- how output files are structured
- type and field naming rules
- enum generation
- auto-generation behavior
- gqlgen integration options
- file-preservation rules via `@gqlKeep` markers

Configure this once and the tool handles the rest.

---

# **1. Packages & Strategy**

## **Packages**

Define the Go packages where annotated structs (`@gqlType`, `@gqlInput`, `@gqlEnum`) are located.

```yaml
packages:
  - ./graph/model/
  - ./domain/
```

## **Output Strategy**

Controls how schema files are generated:

| Strategy   | Meaning                        |
| ---------- | ------------------------------ |
| `single`   | One schema file for everything |
| `multiple` | One file per GraphQL type      |
| `package`  | One file per Go package        |

```yaml
strategy: multiple
```

---

# **2. Output Structure**

## **Output Path**

Directory or file path depending on strategy:

```yaml
output: graph/schema/
```

## **File Naming**

Applies when using `single` or when customizing file names in multi-file modes.

```yaml
output_file_name: gqlschemagen.graphqls
output_file_extension: .graphqls
schema_file_name: "{model_name}.graphqls"
```

---

# **3. Naming Conventions**

## **Field Case Transformation**

How struct field names are turned into GraphQL field names:

```yaml
field_case: camel
```

Options: `camel`, `snake`, `pascal`, `original`, `none`.

## **Use JSON Tags**

Use `json:"..."` tags when `gql` tags are missing.

```yaml
use_json_tag: true
```

## **Type Name Manipulation**

Prefixes & suffixes for type or input names:

```yaml
strip_prefix: ""
strip_suffix: ""

add_type_prefix: ""
add_type_suffix: ""

add_input_prefix: ""
add_input_suffix: "Input"
```

---

# **4. Directives & gqlgen Integration**

Enable or disable generation of gqlgen-compatible helpers:

```yaml
use_gqlgen_directives: false
model_path: ""
```

If enabled, it generates:

- `@goModel`
- `@goField`
- `@goTag`

---

# **5. Auto-Generation (Dependencies)**

GQLSchemaGen can generate types referenced by other annotated types.

```yaml
auto_generate:
  enabled: true
  strategy: referenced
  max_depth: 1
  include_embedded: true
  include_field_types: true
  only_referenced_by_annotated: true
  out_of_scope_types: warn
```

**Strategies:**

- `none`
- `referenced` (recommended)
- `all`
- `patterns`

---

# **6. Enum Support**

Enum generation is handled via:

- `@gqlEnum` on type declarations
- `@gqlEnumValue` on individual constants
- Supports string and iota enums

Nothing special is required in the config, but the config file documents supported features.

---

# **7. Known Scalars**

Add custom scalars to avoid out-of-scope warnings:

```yaml
known_scalars:
  - ID
  - DateTime
  - UUID
  - JSON
  - Bytes
```

---

# **8. File Preservation (GQLKeep)**

Preserve sections between regenerations:

```yaml
keep_section_placement: "end"
keep_begin_marker: "# @gqlKeepBegin"
keep_end_marker: "# @gqlKeepEnd"
```

Place custom code between markers in your schema files and it wonâ€™t be overwritten.

---

# **9. CLI & Watcher Settings**

Optional file-watching:

```yaml
cli:
  watcher:
    enabled: false
    debounce_ms: 500
    additional_paths: []
    ignore_patterns:
      - vendor
      - node_modules
      - .git
```

---

# **Generate Your Schema**

Once the config is set up:

<Snippet>gqlschemagen generate</Snippet>

This processes all annotated structs and outputs schema files according to your chosen strategy.

Example output:

<CodeBlock className="mt-4" language="graphql" filename="schema.graphqls">
  {`"""
  Represents a user in the system
  """
  type UserProfile @goModel(model: "your-package.User") {
    id: ID!
    name: String!
  }`}
</CodeBlock>

---

## Full Example Configuration

Below is the complete recommended config.

<Collapsible title="Full Example: gqlschemagen.yml" label="Full Configuration">
    <CodeBlock language="yaml" filename="gqlschemagen.yml">
{`# gqlschemagen Configuration

tool_version: "0.1.11"

# Packages to scan for Go structs with gql annotations (required)
# Supports direct paths to directories containing Go files
packages:
   - ./

# Output strategy: "single" for one file, "multiple" for separate files per type, "package" for separate files per package
# Options: "single", "multiple", "package"
# Default: "multiple"
strategy: single

# Output path (directory or file path depending on strategy)
output: graph/schema/

# Output file name when using single strategy
# Default: "gqlschemagen.graphqls"
output_file_name: gqlschemagen.graphqls

# Output file extension for multiple/package strategies
# Default: ".graphqls"
output_file_extension: .graphqls

# Field name transformation: camel, snake, pascal, original, none
# - camel: FirstName -> firstName
# - snake: FirstName -> first_name  
# - pascal: FirstName -> FirstName
# - original: Keep as defined in struct
# - none: Keep struct field name untouched
# Default: "camel"
field_case: camel

# Use json struct tags for field names when gql tag is not present
# This will follow the ignore rules of the json package (e.g., json:"-" to ignore fields)
# Default: true
use_json_tag: true 

# Generate gqlgen directives (@goModel, @goField, @goTag)
# Default: false
use_gqlgen_directives: false

# Base path for @goModel directive (leave empty to use actual package path)
# This is only used in the scanned packages, external packages always use their real import path.
# Example: "github.com/user/project/models"
# Default: "" (empty - auto-detected from go.mod)
model_path: ""

# Strip prefixes from type names (e.g., "DB,Pg" converts DBUser -> User)
# Only applies when @gqlType or @gqlInput doesn't specify a custom name
# Default: "" (empty)
strip_prefix: ""

# Strip suffixes from type names (e.g., "DTO,Entity" converts UserDTO -> User)
# Only applies when @gqlType or @gqlInput doesn't specify a custom name
# Default: "" (empty)
strip_suffix: ""

# Add prefix to GraphQL type names (e.g., "Gql" converts User -> GqlUser)
# Only applies when @gqlType doesn't specify a custom name
# Default: "" (empty)
add_type_prefix: ""

# Add suffix to GraphQL type names (e.g., "Type" converts User -> UserType)
# Only applies when @gqlType doesn't specify a custom name
# Default: "" (empty)
add_type_suffix: ""

# Add prefix to GraphQL input names
# Only applies when @gqlInput doesn't specify a custom name
# Default: "" (empty)
add_input_prefix: ""

# Add suffix to GraphQL input names (e.g., "Input" converts CreateUser -> CreateUserInput)
# Only applies when @gqlInput doesn't specify a custom name
# Default: "Input"
add_input_suffix: "Input"

# Schema file name pattern for multiple strategy (supports: {model_name}, {type_name})
# Example: "{type_name}.graphqls" or "{model_name}_schema.graphqls"
# Default: "{model_name}.graphqls"
schema_file_name: "{model_name}.graphqls"

# Include types with no fields in the generated schema
# Default: false
include_empty_types: false

# Skip overwriting existing files when generating
# Default: false
skip_existing: false

# Automatically generate input types from structs with @gqlType
# Default: true
gen_inputs: true

# Generate empty structs (types with no fields)
# Default: false
generate_empty_structs: false

# Namespace separator for converting namespace to file paths
# Example: "/" converts "user.auth" to "user/auth.graphqls"
# Default: "/"
namespace_separator: "/"

# Known GraphQL scalar types (built-in + custom)
# These types are always considered "in scope" and won't trigger out-of-scope warnings
# You can add your own custom scalars here (e.g., "Money", "Color", "URL")
# Default: includes GraphQL built-ins (Int, Float, String, Boolean, ID) and common customs
known_scalars:
   - Int
   - Float
   - String
   - Boolean
   - ID
   - Time
   - DateTime
   - Date
   - Timestamp
   - Upload
   - Map
   - UUID
   - Any
   - JSON
   - Byte
   - Bytes
   - Int64
   - UInt
   - UInt64

# Scalar type mappings (similar to gqlgen models)
# Maps Go types (by full package path) to GraphQL scalars
# This allows you to map types like uuid.UUID to GraphQL ID globally
# Example:
# scalars:
#   ID:
#     model:
#       - github.com/google/uuid.UUID
#       - github.com/gofrs/uuid.UUID
#   DateTime:
#     model:
#       - time.Time
#   Int64:
#     model:
#       - int64
#
# When a Go type matches a model entry, the field will use the scalar type
# instead of generating a new type. Scalar declarations are auto-generated ONLY
# for scalars that are NOT built-in (ID, String, Int, Float, Boolean) and NOT
# in known_scalars section.
scalars:
  # ID:
  #   model:
  #     - github.com/google/uuid.UUID
  # DateTime:
  #   model:
  #     - time.Time

# GQLKeep preserved sections configuration
# Allows you to preserve custom content between regenerations
# Add content between @gqlKeepBegin and @gqlKeepEnd markers in your schema

# Placement of the preserved sections (options: "start", "end")
# Default: "end"
keep_section_placement: "end"

# Markers to denote beginning and end of preserved sections
# Default: "# @gqlKeepBegin"
keep_begin_marker: "# @gqlKeepBegin"
# Default: "# @gqlKeepEnd"
keep_end_marker: "# @gqlKeepEnd"

# Auto-generation configuration
# Automatically generate GraphQL types for structs referenced by annotated types
auto_generate:
   # Enable/disable auto-generation
   # Default: true
   enabled: true
   
   # Strategy for auto-generation:
   # - "none": Disable auto-generation
   # - "referenced": Auto-generate types referenced by annotated types (recommended)
   # - "all": Auto-generate all structs found
   # - "patterns": Auto-generate types matching patterns list
   # Default: "referenced"
   strategy: referenced
   
   # Maximum depth for dependency traversal
   # 0 = unlimited, 1 = direct references only, 2 = direct + transitive
   # Default: 1
   max_depth: 1
   
   # Patterns for type matching (only used when strategy is "patterns")
   # Example: ["*/models/*Connection", "*/graph/model/*Input"]
   # Default: [] (empty)
   patterns: []
   
   # Exclude patterns (applied to all strategies)
   # Example: ["*/internal/*", "*/vendor/*"]
   # Default: ["*/vendor/*", "*/*_test.go"]
   exclude_patterns:
      - "*/vendor/*"
      - "*/*_test.go"
   
   # Only auto-generate types that are referenced by @gql* annotated types
   # Default: true
   only_referenced_by_annotated: true
   
   # Auto-generate embedded struct types
   # Default: true
   include_embedded: true
   
   # Auto-generate field types
   # Default: true
   include_field_types: true
   
   # Action for out-of-scope types (types referenced but not in scanned packages)
   # Options: "warn", "fail", "ignore", "exclude"
   # - "warn": Log warnings about out-of-scope types (default)
   # - "fail": Stop generation if out-of-scope types are found
   # - "ignore": Silently allow out-of-scope type references
   # - "exclude": Automatically exclude fields with out-of-scope types
   # Default: "warn"
   out_of_scope_types: warn

# CLI configuration
cli:
   # File watcher configuration
   watcher:
      # Enable watch mode
      # Default: false
      enabled: false
      
      # Debounce delay in milliseconds
      # Default: 500
      debounce_ms: 500
      
      # Additional paths to watch (beyond packages)
      # Default: [] (empty)
      additional_paths: []
      
      # Paths/patterns to ignore
      # Default: ["vendor", "node_modules", ".git"]
      ignore_patterns:
         - vendor
         - node_modules
         - .git
`}

</CodeBlock>
</Collapsible>

---

To learn how to annotate your structs and generate your first types, continue to the [GQL Types guide](/docs/features/gql-types).

<NextButton href="/docs/features/gql-types">GQL Types</NextButton>
